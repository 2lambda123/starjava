/* ********************************************************
 * This file automatically generated by /d2/starjava/java/source/jniast/src/perl/FitsChan.pl
 * Do not edit
 **********************************************************/

package uk.ac.starlink.ast;

import java.util.Iterator;
import java.util.NoSuchElementException;
import java.io.*;


/**
 * Java interface to the AST FitsChan class
 *  - i/O Channel using FITS header cards to represent Objects. 
 * A FitsChan is a specialised form of Channel which supports I/O
 * operations involving the use of FITS (Flexible Image Transport
 * System) header cards. Writing an Object to a FitsChan (using
 * astWrite) will, if the Object is suitable, generate a
 * description of that Object composed of FITS header cards, and
 * reading from a FitsChan will create a new Object from its FITS
 * header card description.
 * <p>
 * While a FitsChan is active, it represents a buffer which may
 * contain zero or more 80-character "header cards" conforming to
 * FITS conventions. Any sequence of FITS-conforming header cards
 * may be stored, apart from the "END" card whose existence is
 * merely implied.  The cards may be accessed in any order by using
 * the FitsChan's integer Card attribute, which identifies a "current"
 * card, to which subsequent operations apply. Searches
 * based on keyword may be performed (using astFindFits), new
 * cards may be inserted (astPutFits) and existing ones may be
 * deleted (astDelFits).
 * <p>
 * When you create a FitsChan, you have the option of specifying
 * "source" and "sink" functions which connect it to external data
 * stores by reading and writing FITS header cards. If you provide
 * a source function, it is used to fill the FitsChan with header
 * cards when it is created. If you do not provide a source
 * function, the FitsChan remains empty until you explicitly enter
 * data into it (e.g. using astPutFits or astWrite). If you
 * provide a sink function, it is used to deliver any remaining
 * contents of a FitsChan to an external data store when the
 * FitsChan is deleted. If you do not provide a sink function, any
 * header cards remaining when the FitsChan is deleted will be
 * lost, so you should arrange to extract them first if necessary
 * (e.g. using astFindFits or astRead).
 * <p>
 * Coordinate system information may be described using FITS header
 * cards using several different conventions, termed
 * "encodings". When an AST Object is written to (or read from) a
 * FitsChan, the value of the FitsChan's Encoding attribute
 * determines how the Object is converted to (or from) a
 * description involving FITS header cards. In general, different
 * encodings will result in different sets of header cards to
 * describe the same Object. Examples of encodings include the DSS
 * encoding (based on conventions used by the STScI Digitised Sky
 * Survey data), the FITS-WCS encoding (based on a proposed FITS
 * standard) and the NATIVE encoding (a near loss-less way of
 * storing AST Objects in FITS headers).
 * <p>
 * The available encodings differ in the range of Objects they can
 * represent, in the number of Object descriptions that can coexist
 * in the same FitsChan, and in their accessibility to other
 * (external) astronomy applications (see the Encoding attribute
 * for details). Encodings are not necessarily mutually exclusive
 * and it may sometimes be possible to describe the same Object in
 * several ways within a particular set of FITS header cards by
 * using several different encodings.
 * <p>
 * The detailed behaviour of astRead and astWrite, when used with
 * a FitsChan, depends on the encoding in use. In general, however,
 * all use of astRead is destructive, so that FITS header cards
 * are consumed in the process of reading an Object, and are
 * removed from the FitsChan.
 * <p>
 * If the encoding in use allows only a single Object description
 * to be stored in a FitsChan (e.g. the DSS, FITS-WCS and FITS-IRAF
 * encodings), then write operations using astWrite will
 * over-write any existing Object description using that
 * encoding. Otherwise (e.g. the NATIVE encoding), multiple Object
 * descriptions are written sequentially and may later be read
 * back in the same sequence.
 * <p>
 * Note, currently the FitsChan class does not recognise spectral axes. 
 * They are treated as an ``unknown'' axis type, and are represented by
 * simple a 1-dimensional Frame (not a SpecFrame).
 * 
 * <p>
 *       <h4>Usage</h4>
 *       The FitsChan implemented by this class can be used as a buffer for
 *       FITS header cards, but it neither reads from nor writes to an
 *       external source.  To make a more useful object, subclass this
 *       class and override the <code>source</code> and/or <code>sink</code>
 *       methods.  Note that output is only guaranteed to get written
 *       if the <code>finalize</code> method is explicitly called.
 *    
 * 
 * @see  <a href='http://star-www.rl.ac.uk/cgi-bin/htxserver/sun211.htx/?xref_FitsChan'>AST FitsChan</a> 
 * @author   Mark Taylor (Starlink) 
 */

public class FitsChan extends Channel {

    /* Holds the C pointer to a data structure used by native code. */
    private long chaninfo;

    /* An iterator used by the source method. */
    private Iterator cardIt;

    /**
     * Creates a new FitsChan whose initial contents will be a sequence of
     * FITS header cards obtained from an Iterator.
     *
     * @param   cardIt  an Iterator which should supply Strings giving the
     *                  channel's initial content.  Only the first 80
     *                  characters of each supplied string are significant.
     *                  This parameter may be supplied null in the case of
     *                  no initial content.
     */
    public FitsChan( Iterator cardIt ) {
        if ( cardIt == null ) {
            cardIt = new Iterator() {
                public boolean hasNext() {
                    return false;
                }
                public Object next() {
                    throw new NoSuchElementException();
                }
                public void remove() {
                    throw new UnsupportedOperationException();
                }
            };
        }
        this.cardIt = cardIt;

        /* Perform native initialisation. */
        construct();
    }

    /**
     * Creates a new FitsChan which can be used as a buffer for
     * FITS objects, but will not read or write header cards.
     */
    public FitsChan() {
        this( null );
    }
    private native void construct();

    /**
     * Returns an iterator over the header cards currently in this FitsChan.
     * Each object returned from the Iterator's <code>next</code> method
     * will be an 80-character String.  The Iterator's <code>remove</code>
     * method can be used to delete cards from the underlying channel.
     * The iterator should not be used while the FitsChan is being 
     * written to.
     * <p>
     * This method is a convenience wrapper which uses <code>findFits</code>
     * and <code>delFits</code> to do the work.
     *
     * @return  an Iterator which retrieves each line from the FitsChan in turn
     */
    public Iterator iterator() {
        return new Iterator() {
            private int icard = 1;
            private int removable = -1;
            public boolean hasNext() {
                return icard <= getNcard();
            }
            public Object next() {
                if ( ! hasNext() ) {
                    throw new NoSuchElementException();
                }
                else {
                    int ic = getCard();
                    setCard( icard );
                    removable = icard++;
                    String line = findFits( "%f", false );
                    setCard( ic );
                    return line;
                }
            }
            public void remove() {
                if ( removable > 0 ) {
                    int ic = getCard();
                    setCard( removable );
                    delFits();
                    icard--;
                    if ( ic > removable ) { 
                        ic--;
                    }
                    setCard( ic );
                    removable = 0;
                }
                else {
                    throw new IllegalStateException();
                }
            }
        };
    }

    /**
     * Disposes of a line of output.  This method is invoked repeatedly 
     * when the <code>finalize</code> method of this FitsChan is called 
     * (either explicitly or under control of the garbage collector)
     * to dispose of each FITS header card currently in the channel.
     *
     * The <code>FitsChan</code> implementation simply discards each
     * line, but it may be overridden by subclasses to output the header
     * cards in a useful way.  The method may throw an IOException in case
     * of error.
     *
     * @param  line  an 80-character string giving the contents of one
     *               FITS header card.  This method discards it.
     * @throws IOException  if a write error is encountered
     */
    protected void sink( String line ) throws IOException {
    }

    /**
     * Obtains a line of input.  This method is invoked repeatedly during 
     * construction of this FitsChan to obtain its initial contents.
     * On each call it returns the text of the next FITS header card
     * if there is one, and <code>null</code> if there are no more.
     *
     * The <code>FitsChan</code> implementation uses the Iterator 
     * supplied in the constructor to obtain the lines of text.
     * It is declared final to prevent subclasses overriding it -
     * algthough in principle it could work, this practice would be
     * fraught with difficulty since the method is called by the 
     * FitsChan constructor before the subclassed object has been 
     * properly constucted, so it is likely to be in an inconsistent state.
     */
    final protected String source() {
        return cardIt.hasNext() ? (String) cardIt.next() : null;
    }

    /**
     * Finalizes the object.  When this method is called, either explicitly
     * or under control of the garbage collector, the <code>sink</code>
     * method will be invoked to write out any content of this 
     * <code>FitsChan</code>
     */
    public void finalize() throws Throwable {
        destroy();
        super.finalize();
    }
    private native void destroy();

    /**
     * Reads an AST object from this FitsChan.
     *
     * @throws  AstException  if an error occurs in the AST library
     */
    public native AstObject read();

    /**
     * Writes an AST object to this channel.  
     *
     * @param    obj  an <code>AstObject</code> to be written
     * @throws   AstException  if an error occurs in the AST library
     */
    public native void write( AstObject obj );

    /** 
     * Delete the current FITS card in a FitsChan.   
     * This function deletes the current FITS card from a FitsChan. The
     * current card may be selected using the Card attribute (if its index
     * is known) or by using astFindFits (if only the FITS keyword is
     * known).
     * <p>
     * After deletion, the following card becomes the current card.
     * <h4>Notes</h4>
     * <br> - This function returns without action if the FitsChan is
     * initially positioned at the "end-of-file" (i.e. if the Card
     * attribute exceeds the number of cards in the FitsChan).
     * <br> - If there are no subsequent cards in the FitsChan, then the
     * Card attribute is left pointing at the "end-of-file" after
     * deletion (i.e. is set to one more than the number of cards in
     * the FitsChan).
     * @throws  AstException  if an error occurred in the AST library
     */
    public native void delFits(  );

    /** 
     * Find a FITS card in a FitsChan by keyword.   
     * This function searches for a card in a FitsChan by keyword. The
     * search commences at the current card (identified by the Card
     * attribute) and ends when a card is found whose FITS keyword
     * matches the template supplied, or when the last card in the
     * FitsChan has been searched.
     * <p>
     * If the search is successful (i.e. a card is found which matches
     * the template), the contents of the card are (optionally)
     * returned and the Card attribute is adjusted to identify the card
     * found or, if required, the one following it. If the search is
     * not successful, the function returns zero and the Card attribute
     * is set to the "end-of-file".
     * <h4>Notes</h4>
     * <br> - The search always starts with the current card, as identified
     * by the Card attribute. To ensure you search the entire contents
     * of a FitsChan, you should first clear the Card attribute (using
     * astClear). This effectively "rewinds" the FitsChan.
     * <br> - If a search is unsuccessful, the Card attribute is set to the
     * "end-of-file" (i.e. to one more than the number of cards in the
     * FitsChan). No error occurs.
     * <br> - A value of zero will be returned if this function is invoked
     * with the AST error status set, or if it should fail for any
     * reason.
     * <h4>Keyword Templates</h4>
     * The templates used to match FITS keywords are normally composed
     * of literal characters, which must match the keyword exactly
     * (apart from case). However, a template may also contain "field
     * specifiers" which can match a range of possible characters. This
     * allows you to search for keywords that contain (for example)
     * numbers, where the digits comprising the number are not known in
     * advance.
     * <p>
     * A field specifier starts with a "%" character. This is followed
     * by an optional single digit (0 to 9) specifying a field
     * width. Finally, there is a single character which specifies the
     * type of character to be matched, as follows:
     * <p>
     * <br> - "c": matches all upper case letters,
     * <br> - "d": matches all decimal digits,
     * <br> - "f": matches all characters which are permitted within a FITS
     * keyword (upper case letters, digits, underscores and hyphens).
     * <p>
     * If the field width is omitted, the field specifier matches one
     * or more characters. If the field width is zero, it matches zero
     * or more characters. Otherwise, it matches exactly the number of
     * characters specified. In addition to this:
     * <p>
     * <br> - The template "%f" will match a blank FITS keyword consisting
     * of 8 spaces (as well as matching all other keywords).
     * <br> - A template consisting of 8 spaces will match a blank keyword
     * (only).
     * <p>
     * For example:
     * <p>
     * <br> - The template "BitPix" will match the keyword "BITPIX" only.
     * <br> - The template "crpix%1d" will match keywords consisting of
     * "CRPIX" followed by one decimal digit.
     * <br> - The template "P%c" will match any keyword starting with "P"
     * and followed by one or more letters.
     * <br> - The template "E%0f" will match any keyword beginning with "E".
     * <br> - The template "%f" will match any keyword at all (including a
     * blank one).
     * @param   name
     * Pointer to a null-terminated character string containing a
     * template for the keyword to be found. In the simplest case,
     * this should simply be the keyword name (the search is case
     * insensitive and trailing spaces are ignored). However, this
     * template may also contain "field specifiers" which are
     * capable of matching a range of characters (see the "Keyword
     * Templates" section for details). In this case, the first card
     * with a keyword which matches the template will be found. To
     * find the next FITS card regardless of its keyword, you should
     * use the template "%f".
     * 
     * @param   inc
     * If this value is zero (and the search is successful), the
     * FitsChan's Card attribute will be set to the index of the card
     * that was found. If it is non-zero, however, the Card
     * attribute will be incremented to identify the card which
     * follows the one found.
     * 
     * @return  An array of at least 81 characters (to allow room for a
     * terminating null)
     * in which the FITS card which is found will be returned.  If
     * the search is not successful (or a NULL pointer is given), a
     * card will not be returned.
     * 
     * @throws  AstException  if an error occurred in the AST library
     */
    public native String findFits( String name, boolean inc );

    /** 
     * Store a FITS header card in a FitsChan.   
     * This function stores a FITS header card in a FitsChan. The card
     * is either inserted before the current card (identified by the
     * Card attribute), or over-writes the current card, as required.
     * <h4>Notes</h4>
     * <br> - If the Card attribute initially points at the "end-of-file"
     * (i.e. exceeds the number of cards in the FitsChan), then the new
     * card is appended as the last card in the FitsChan.
     * <br> - An error will result if the supplied string cannot be interpreted
     * as a FITS header card.
     * @param   card
     * Pointer to a possibly null-terminated character string
     * containing the FITS card to be stored. No more than 80
     * characters will be used from this string (or fewer if a null
     * occurs earlier).
     * 
     * @param   overwrite
     * If this value is zero, the new card is inserted in front of
     * the current card in the FitsChan (as identified by the
     * initial value of the Card attribute). If it is non-zero, the
     * new card replaces the current card. In either case, the Card
     * attribute is then incremented by one so that it subsequently
     * identifies the card following the one stored.
     * 
     * @throws  AstException  if an error occurred in the AST library
     */
    public native void putFits( String card, boolean overwrite );

    /**
     * Get 
     * index of current FITS card in a FitsChan.  
     * This attribute gives the index of the "current" FITS header card
     * within a FitsChan, the first card having an index of 1. The
     * choice of current card affects the behaviour of functions that
     * access the contents of the FitsChan, such as astDelFits,
     * astFindFits and astPutFits.
     * <p>
     * A value assigned to Card will position the FitsChan at any
     * desired point, so that a particular card within it can be
     * accessed. Alternatively, the value of Card may be enquired in
     * order to determine the current position of a FitsChan.
     * <p>
     * The default value of Card is 1. This means that clearing
     * this attribute (using astClear) effectively "rewinds" the
     * FitsChan, so that the first card is accessed next.  If Card is
     * set to a value which exceeds the total number of cards in the
     * FitsChan (as given by its Ncards attribute), it is regarded as
     * pointing at the "end-of-file". In this case, the value returned
     * in response to an enquiry is always one more than the number of
     * cards in the FitsChan.
     * 
     *
     * @return  card  this object's Card attribute
     */
    public int getCard() {
        return getI( "Card" );
    }

    /**
     * Set 
     * index of current FITS card in a FitsChan.  
     * This attribute gives the index of the "current" FITS header card
     * within a FitsChan, the first card having an index of 1. The
     * choice of current card affects the behaviour of functions that
     * access the contents of the FitsChan, such as astDelFits,
     * astFindFits and astPutFits.
     * <p>
     * A value assigned to Card will position the FitsChan at any
     * desired point, so that a particular card within it can be
     * accessed. Alternatively, the value of Card may be enquired in
     * order to determine the current position of a FitsChan.
     * <p>
     * The default value of Card is 1. This means that clearing
     * this attribute (using astClear) effectively "rewinds" the
     * FitsChan, so that the first card is accessed next.  If Card is
     * set to a value which exceeds the total number of cards in the
     * FitsChan (as given by its Ncards attribute), it is regarded as
     * pointing at the "end-of-file". In this case, the value returned
     * in response to an enquiry is always one more than the number of
     * cards in the FitsChan.
     * 
     *
     * @param  card   the Card attribute of this object
     */
    public void setCard( int card ) {
       setI( "Card", card );
    }

    /**
     * Get 
     * ignore spherical rotations on CAR projections.  
     * This attribute is a boolean value which specifies how FITS "CAR"
     * (plate carree, or "Cartesian") projections should be treated when
     * reading a FrameSet from a foreign encoded FITS header. If zero (the
     * default), it is assumed that the CAR projection conforms to the
     * conventions described in the (draft) FITS world coordinate system 
     * (FITS-WCS) paper by E.W. Greisen and M. Calabretta (A & A, in 
     * preparation). If CarLin is non-zero, then these conventions are
     * ignored, and it is assumed that the mapping from pixel coordinates to 
     * celestial coordinates is a simple linear transformation (hence the 
     * attribute name "CarLin"). This is appropriate for some older FITS 
     * data which claims to have a "CAR" projection, but which in fact do
     * not conform to the conventions of the FITS-WCS paper. Furthermore, if
     * CarLin is non-zero, it is assumed that CDELT and CD keywords are
     * in units of degrees rather than radians (as required by the
     * FITS-WCS papers).
     * <p>
     * The FITS-WCS paper specifies that headers which include a CAR projection 
     * represent a linear mapping from pixel coordinates to "native spherical 
     * coordinates", NOT celestial coordinates. An extra mapping is then
     * required from native spherical to celestial. This mapping is a 3D
     * rotation and so the overall Mapping from pixel to celestial coordinates 
     * is NOT linear. See the FITS-WCS papers for further details.
     * 
     *
     * @return  carLin  this object's CarLin attribute
     */
    public boolean getCarLin() {
        return getB( "CarLin" );
    }

    /**
     * Set 
     * ignore spherical rotations on CAR projections.  
     * This attribute is a boolean value which specifies how FITS "CAR"
     * (plate carree, or "Cartesian") projections should be treated when
     * reading a FrameSet from a foreign encoded FITS header. If zero (the
     * default), it is assumed that the CAR projection conforms to the
     * conventions described in the (draft) FITS world coordinate system 
     * (FITS-WCS) paper by E.W. Greisen and M. Calabretta (A & A, in 
     * preparation). If CarLin is non-zero, then these conventions are
     * ignored, and it is assumed that the mapping from pixel coordinates to 
     * celestial coordinates is a simple linear transformation (hence the 
     * attribute name "CarLin"). This is appropriate for some older FITS 
     * data which claims to have a "CAR" projection, but which in fact do
     * not conform to the conventions of the FITS-WCS paper. Furthermore, if
     * CarLin is non-zero, it is assumed that CDELT and CD keywords are
     * in units of degrees rather than radians (as required by the
     * FITS-WCS papers).
     * <p>
     * The FITS-WCS paper specifies that headers which include a CAR projection 
     * represent a linear mapping from pixel coordinates to "native spherical 
     * coordinates", NOT celestial coordinates. An extra mapping is then
     * required from native spherical to celestial. This mapping is a 3D
     * rotation and so the overall Mapping from pixel to celestial coordinates 
     * is NOT linear. See the FITS-WCS papers for further details.
     * 
     *
     * @param  carLin   the CarLin attribute of this object
     */
    public void setCarLin( boolean carLin ) {
       setB( "CarLin", carLin );
    }

    /**
     * Get 
     * use FK4 B1950 as defaults.  
     * This attribute is a boolean value which specifies a default equinox
     * and reference frame to use when reading a FrameSet from a FitsChan
     * with a foreign (i.e. non-native) encoding. It is only used if the FITS 
     * header contains no information about the reference frame or equinox. If
     * this is the case, then values of FK4 and B1950 are assumed if the 
     * DefB1950 attribute has a non-zero value (the default), and FK5 J2000 
     * is assumed if DefB1950 is zero.
     * 
     *
     * @return  defB1950  this object's DefB1950 attribute
     */
    public boolean getDefB1950() {
        return getB( "DefB1950" );
    }

    /**
     * Set 
     * use FK4 B1950 as defaults.  
     * This attribute is a boolean value which specifies a default equinox
     * and reference frame to use when reading a FrameSet from a FitsChan
     * with a foreign (i.e. non-native) encoding. It is only used if the FITS 
     * header contains no information about the reference frame or equinox. If
     * this is the case, then values of FK4 and B1950 are assumed if the 
     * DefB1950 attribute has a non-zero value (the default), and FK5 J2000 
     * is assumed if DefB1950 is zero.
     * 
     *
     * @param  defB1950   the DefB1950 attribute of this object
     */
    public void setDefB1950( boolean defB1950 ) {
       setB( "DefB1950", defB1950 );
    }

    /**
     * Get 
     * system for encoding Objects as FITS headers.  
     * This attribute specifies the encoding system to use when AST
     * Objects are stored as FITS header cards in a FitsChan. It
     * affects the behaviour of the astWrite and astRead functions when
     * they are used to transfer any AST Object to or from an external
     * representation consisting of FITS header cards (i.e. whenever a
     * write or read operation is performed using a FitsChan as the I/O
     * Channel).
     * <p>
     * There are several ways (conventions) by which coordinate system
     * information may be represented in the form of FITS headers and
     * the Encoding attribute is used to specify which of these should
     * be used. The encoding options available are outlined in the
     * "Encodings Available" section below, and in more detail in the
     * sections which follow.
     * <p>
     * Encoding systems differ in the range of possible Objects
     * (e.g. classes) they can represent, in the restrictions they
     * place on these Objects (e.g. compatibility with some
     * externally-defined coordinate system model) and in the number of
     * Objects that can be stored together in any particular set of
     * FITS header cards (e.g. multiple Objects, or only a single
     * Object). The choice of encoding also affects the range of
     * external applications which can potentially read and interpret
     * the FITS header cards produced.
     * <p>
     * The encoding options available are not necessarily mutually
     * exclusive, and it may sometimes be possible to store multiple
     * Objects (or the same Object several times) using different
     * encodings within the same set of FITS header cards. This
     * possibility increases the likelihood of other applications being
     * able to read and interpret the information.
     * <p>
     * By default, a FitsChan will attempt to determine which encoding
     * system is already in use, and will set the default Encoding
     * value accordingly (so that subsequent I/O operations adopt the
     * same conventions). It does this by looking for certain critical
     * FITS keywords which only occur in particular encodings. For
     * details of how this works, see the "Choice of Default Encoding"
     * section below. If you wish to ensure that a particular encoding
     * system is used, independently of any FITS cards already present,
     * you should set an explicit Encoding value yourself.
     * <h4>Encodings Available</h4>
     * The Encoding attribute can take any of the following (case
     * insensitive) string values to select the corresponding encoding
     * system:
     * <p>
     * <br> - "DSS": Encodes coordinate system information in FITS header
     * cards using the convention developed at the Space Telescope
     * Science Institute (STScI) for the Digitised Sky Survey (DSS)
     * astrometric plate calibrations. The main advantages of this
     * encoding are that FITS images which use it are widely available
     * and it is understood by a number of important and
     * well-established astronomy applications. For further details,
     * see the section "The DSS Encoding" below.
     * <p>
     * <br> - "FITS-WCS": Encodes coordinate system information in FITS
     * header cards using the conventions described in the (draft) FITS
     * world coordinate system (FITS-WCS) paper by E.W. Greisen and
     * M. Calabretta (A & A, in preparation). The main advantages of
     * this encoding are that it should be understood by any FITS-WCS
     * compliant application and is likely to be adopted widely for
     * FITS data in future. At present, however, it suffers from the
     * disadvantage that the FITS-WCS standard is only a draft (and is
     * not stable), so it cannot yet be recommended for regular
     * use. For further details, see the section "The FITS-WCS
     * Encoding" below.
     * <p>
     * <br> - "FITS-PC": Encodes coordinate system information in FITS
     * header cards using the conventions described in an earlier draft
     * of the FITS world coordinate system paper by E.W. Greisen and
     * M. Calabretta. This encoding uses a combination of CDELTi and
     * PCiiijjj keywords to describe the scale and rotation of the pixel
     * axes. This encoding is included to support existing data and  
     * software which uses these now superceded conventions. In general,
     * the "FITS-WCS" encoding (which uses CDi_j keywords to describe the
     * scale and rotation) should be used in preference to "FITS-PC".
     * <p>
     * <br> - "FITS-IRAF": Encodes coordinate system information in FITS
     * header cards using the conventions described in the document
     * "World Coordinate Systems Representations Within the FITS
     * Format" by R.J. Hanisch and D.G. Wells, 1988.  This encoding is
     * currently employed by the IRAF data analysis facility, so its
     * use will facilitate data exchange with IRAF. Its main advantages
     * are that it is a stable convention which approximates to a
     * subset of the propsed FITS-WCS encoding (above). This makes it
     * suitable as an interim method for storing coordinate system
     * information in FITS headers until the FITS-WCS encoding becomes
     * stable. Since many datasets currently use the FITS-IRAF
     * encoding, conversion of data from FITS-IRAF to the final form of
     * FITS-WCS is likely to be well supported.
     * <p>
     * <br> - "FITS-AIPS": Encodes coordinate system information in FITS
     * header cards using the conventions originally introduced by the 
     * AIPS data analysis facility. This is base on the use of CDELTi and
     * CROTAi keuwords to desribe the scale and rotation of each axis.
     * These conventions have been superceded but are still widely used.
     * <p>
     * <br> - "NATIVE": Encodes AST Objects in FITS header cards using a
     * convention which is private to the AST library (but adheres to
     * the general FITS standard) and which uses FITS keywords that
     * will not clash with other encoding systems. The main advantages
     * of this are that any class of AST Object may be encoded, and any
     * (reasonable) number of Objects may be stored sequentially in the
     * same FITS header. This makes FITS headers an almost loss-less
     * communication path for passing AST Objects between applications
     * (although all such applications must, of course, make use of the
     * AST library to interpret the information). For further details,
     * see the section "The NATIVE Encoding" below.
     * <h4>Choice of Default Encoding</h4>
     * If the Encoding attribute of a FitsChan is not set, the default
     * value it takes is determined by the presence of certain critical
     * FITS keywords within the FitsChan. The sequence of decisions
     * used to arrive at the default value is as follows:
     * <p>
     * <br> - If the FitsChan contains any keywords beginning with the
     * string "BEGAST", then NATIVE encoding is used,
     * <br> - Otherwise, if the FitsChan contains a keyword of the form
     * "PCiiijjj", where "i" and "j" are single digits, then
     * FITS-PC encoding is used,
     * <br> - Otherwise, if the FitsChan contains a keyword of the form
     * "CDiiijjj", where "i" and "j" are single digits, then
     * FITS-IRAF encoding is used,
     * <br> - Otherwise, if the FitsChan contains a keyword of the form
     * "CDi_j", and at least one of RADECSYS, PROJPi, or CjVALi
     * where "i" and "j" are single digits, then FITS-IRAF encoding is 
     * used.
     * <br> - Otherwise, if the FitsChan contains any keywords of the form
     * PROJPi, CjVALi or RADECSYS, where "i" and "j" are single digits, 
     * then FITS-PC encoding is used.
     * <br> - Otherwise, if the FitsChan contains a keyword of the form
     * CROTAi, where "i" is a single digit, then FITS-AIPS encoding is 
     * used.
     * <br> - Otherwise, if the FitsChan contains a keyword of the form
     * CDELTi, where "i" is a single digit, then FITS-PC encoding is 
     * used.
     * <br> - Otherwise, if the FitsChan contains a keyword of the form
     * CRVALi, where "i" is a single digit, then FITS-WCS encoding is 
     * used.
     * <br> - Otherwise, if the FitsChan contains the "PLTRAH" keyword, then
     * DSS encoding is used,
     * <br> - Otherwise, if none of these conditions is met (as would be the
     * case when using an empty FitsChan), then NATIVE encoding is
     * used.
     * <p>
     * Setting an explicit value for the Encoding attribute always
     * over-rides this default behaviour.
     * <p>
     * Note that when writing information to a FitsChan, the choice of
     * encoding will depend greatly on the type of application you
     * expect to be reading the information in future. If you do not
     * know this, there may sometimes be an advantage in writing the
     * information several times, using a different encoding on each
     * occasion.
     * <h4>The DSS Encoding</h4>
     * The DSS encoding uses FITS header cards to store a multi-term
     * polynomial which relates pixel positions on a digitised
     * photographic plate to celestial coordinates (right ascension and
     * declination). This encoding may only be used to store a single
     * AST Object in any set of FITS header cards, and that Object must
     * be a FrameSet which conforms to the STScI/DSS coordinate system
     * model (this means the Mapping which relates its base and current 
     * Frames must include either a DssMap or a WcsMap with type 
     * AST__TAN or AST__TPN).
     * <p>
     * When reading a DSS encoded Object (using astRead), the FitsChan
     * concerned must initially be positioned at the first card (its
     * Card attribute must equal 1) and the result of the read, if
     * successful, will always be a pointer to a FrameSet. The base
     * Frame of this FrameSet represents DSS pixel coordinates, and the
     * current Frame represents DSS celestial coordinates. Such a read
     * is always destructive and causes the FITS header cards required
     * for the construction of the FrameSet to be removed from the
     * FitsChan, which is then left positioned at the "end-of-file". A
     * subsequent read using the same encoding will therefore not
     * return another FrameSet, even if the FitsChan is rewound.
     * <p>
     * When astWrite is used to store a FrameSet using DSS encoding,
     * an attempt is first made to simplify the FrameSet to see if it
     * conforms to the DSS model.  Specifically, the current Frame must 
     * be a default FK5 SkyFrame; the projection must be a tangent plane 
     * (gnomonic) projection with polynomial corrections conforming to 
     * DSS requirements, and north must be parallel to the second base
     * Frame axis.
     * <p>
     * If the simplification process succeeds, a description of the
     * FrameSet is written to the FitsChan using appropriate DSS FITS
     * header cards. The base Frame of the FrameSet is used to form the
     * DSS pixel coordinate system and the current Frame gives the DSS
     * celestial coordinate system.  A successful write operation will
     * over-write any existing DSS encoded data in the FitsChan, but
     * will not affect other (non-DSS) header cards. If a destructive
     * read of a DSS encoded Object has previously occurred, then an
     * attempt will be made to store the FITS header cards back in
     * their original locations.
     * <p>
     * If an attempt to simplify a FrameSet to conform to the DSS model
     * fails (or if the Object supplied is not a FrameSet), then no
     * data will be written to the FitsChan and astWrite will return
     * zero. No error will result.
     * <h4>The NATIVE Encoding</h4>
     * The NATIVE encoding may be used to store a description of any
     * class of AST Object in the form of FITS header cards, and (for
     * most practical purposes) any number of these Object descriptions
     * may be stored within a single set of FITS cards. If multiple
     * Object descriptions are stored, they are written and read
     * sequentially. The NATIVE encoding makes use of unique FITS
     * keywords which are designed not to clash with keywords that have
     * already been used for other purposes (if a potential clash is
     * detected, an alternative keyword is constructed to avoid the
     * clash).
     * <p>
     * When reading a NATIVE encoded object from a FitsChan (using
     * astRead), FITS header cards are read, starting at the current
     * card (as determined by the Card attribute), until the start of
     * the next Object description is found. This description is then
     * read and converted into an AST Object, for which a pointer is
     * returned. Such a read is always destructive and causes all the
     * FITS header cards involved in the Object description to be
     * removed from the FitsChan, which is left positioned at the
     * following card.
     * <p>
     * The Object returned may be of any class, depending on the
     * description that was read, and other AST routines may be used to
     * validate it (for example, by examining its Class or ID attribute
     * using astGetC). If further NATIVE encoded Object descriptions
     * exist in the FitsChan, subsequent calls to astRead will return
     * the Objects they describe in sequence (and destroy their
     * descriptions) until no more remain between the current card and
     * the "end-of-file".
     * <p>
     * When astWrite is used to write an Object using NATIVE encoding,
     * a description of the Object is inserted immediately before the
     * current card (as determined by the Card attribute).  Multiple
     * Object descriptions may be written in this way and are stored
     * separately (and sequentially if the Card attribute is not
     * modified between the writes). A write operation using the NATIVE
     * encoding does not over-write previously written Object
     * descriptions. Note, however, that subsequent behaviour is
     * undefined if an Object description is written inside a
     * previously-written description, so this should be avoided.
     * <p>
     * When an Object is written to a FitsChan using NATIVE encoding,
     * astWrite should (barring errors) always transfer data and
     * return a value of 1.
     * 
     *
     * @return  encoding  this object's Encoding attribute
     */
    public String getEncoding() {
        return getC( "Encoding" );
    }

    /**
     * Set 
     * system for encoding Objects as FITS headers.  
     * This attribute specifies the encoding system to use when AST
     * Objects are stored as FITS header cards in a FitsChan. It
     * affects the behaviour of the astWrite and astRead functions when
     * they are used to transfer any AST Object to or from an external
     * representation consisting of FITS header cards (i.e. whenever a
     * write or read operation is performed using a FitsChan as the I/O
     * Channel).
     * <p>
     * There are several ways (conventions) by which coordinate system
     * information may be represented in the form of FITS headers and
     * the Encoding attribute is used to specify which of these should
     * be used. The encoding options available are outlined in the
     * "Encodings Available" section below, and in more detail in the
     * sections which follow.
     * <p>
     * Encoding systems differ in the range of possible Objects
     * (e.g. classes) they can represent, in the restrictions they
     * place on these Objects (e.g. compatibility with some
     * externally-defined coordinate system model) and in the number of
     * Objects that can be stored together in any particular set of
     * FITS header cards (e.g. multiple Objects, or only a single
     * Object). The choice of encoding also affects the range of
     * external applications which can potentially read and interpret
     * the FITS header cards produced.
     * <p>
     * The encoding options available are not necessarily mutually
     * exclusive, and it may sometimes be possible to store multiple
     * Objects (or the same Object several times) using different
     * encodings within the same set of FITS header cards. This
     * possibility increases the likelihood of other applications being
     * able to read and interpret the information.
     * <p>
     * By default, a FitsChan will attempt to determine which encoding
     * system is already in use, and will set the default Encoding
     * value accordingly (so that subsequent I/O operations adopt the
     * same conventions). It does this by looking for certain critical
     * FITS keywords which only occur in particular encodings. For
     * details of how this works, see the "Choice of Default Encoding"
     * section below. If you wish to ensure that a particular encoding
     * system is used, independently of any FITS cards already present,
     * you should set an explicit Encoding value yourself.
     * <h4>Encodings Available</h4>
     * The Encoding attribute can take any of the following (case
     * insensitive) string values to select the corresponding encoding
     * system:
     * <p>
     * <br> - "DSS": Encodes coordinate system information in FITS header
     * cards using the convention developed at the Space Telescope
     * Science Institute (STScI) for the Digitised Sky Survey (DSS)
     * astrometric plate calibrations. The main advantages of this
     * encoding are that FITS images which use it are widely available
     * and it is understood by a number of important and
     * well-established astronomy applications. For further details,
     * see the section "The DSS Encoding" below.
     * <p>
     * <br> - "FITS-WCS": Encodes coordinate system information in FITS
     * header cards using the conventions described in the (draft) FITS
     * world coordinate system (FITS-WCS) paper by E.W. Greisen and
     * M. Calabretta (A & A, in preparation). The main advantages of
     * this encoding are that it should be understood by any FITS-WCS
     * compliant application and is likely to be adopted widely for
     * FITS data in future. At present, however, it suffers from the
     * disadvantage that the FITS-WCS standard is only a draft (and is
     * not stable), so it cannot yet be recommended for regular
     * use. For further details, see the section "The FITS-WCS
     * Encoding" below.
     * <p>
     * <br> - "FITS-PC": Encodes coordinate system information in FITS
     * header cards using the conventions described in an earlier draft
     * of the FITS world coordinate system paper by E.W. Greisen and
     * M. Calabretta. This encoding uses a combination of CDELTi and
     * PCiiijjj keywords to describe the scale and rotation of the pixel
     * axes. This encoding is included to support existing data and  
     * software which uses these now superceded conventions. In general,
     * the "FITS-WCS" encoding (which uses CDi_j keywords to describe the
     * scale and rotation) should be used in preference to "FITS-PC".
     * <p>
     * <br> - "FITS-IRAF": Encodes coordinate system information in FITS
     * header cards using the conventions described in the document
     * "World Coordinate Systems Representations Within the FITS
     * Format" by R.J. Hanisch and D.G. Wells, 1988.  This encoding is
     * currently employed by the IRAF data analysis facility, so its
     * use will facilitate data exchange with IRAF. Its main advantages
     * are that it is a stable convention which approximates to a
     * subset of the propsed FITS-WCS encoding (above). This makes it
     * suitable as an interim method for storing coordinate system
     * information in FITS headers until the FITS-WCS encoding becomes
     * stable. Since many datasets currently use the FITS-IRAF
     * encoding, conversion of data from FITS-IRAF to the final form of
     * FITS-WCS is likely to be well supported.
     * <p>
     * <br> - "FITS-AIPS": Encodes coordinate system information in FITS
     * header cards using the conventions originally introduced by the 
     * AIPS data analysis facility. This is base on the use of CDELTi and
     * CROTAi keuwords to desribe the scale and rotation of each axis.
     * These conventions have been superceded but are still widely used.
     * <p>
     * <br> - "NATIVE": Encodes AST Objects in FITS header cards using a
     * convention which is private to the AST library (but adheres to
     * the general FITS standard) and which uses FITS keywords that
     * will not clash with other encoding systems. The main advantages
     * of this are that any class of AST Object may be encoded, and any
     * (reasonable) number of Objects may be stored sequentially in the
     * same FITS header. This makes FITS headers an almost loss-less
     * communication path for passing AST Objects between applications
     * (although all such applications must, of course, make use of the
     * AST library to interpret the information). For further details,
     * see the section "The NATIVE Encoding" below.
     * <h4>Choice of Default Encoding</h4>
     * If the Encoding attribute of a FitsChan is not set, the default
     * value it takes is determined by the presence of certain critical
     * FITS keywords within the FitsChan. The sequence of decisions
     * used to arrive at the default value is as follows:
     * <p>
     * <br> - If the FitsChan contains any keywords beginning with the
     * string "BEGAST", then NATIVE encoding is used,
     * <br> - Otherwise, if the FitsChan contains a keyword of the form
     * "PCiiijjj", where "i" and "j" are single digits, then
     * FITS-PC encoding is used,
     * <br> - Otherwise, if the FitsChan contains a keyword of the form
     * "CDiiijjj", where "i" and "j" are single digits, then
     * FITS-IRAF encoding is used,
     * <br> - Otherwise, if the FitsChan contains a keyword of the form
     * "CDi_j", and at least one of RADECSYS, PROJPi, or CjVALi
     * where "i" and "j" are single digits, then FITS-IRAF encoding is 
     * used.
     * <br> - Otherwise, if the FitsChan contains any keywords of the form
     * PROJPi, CjVALi or RADECSYS, where "i" and "j" are single digits, 
     * then FITS-PC encoding is used.
     * <br> - Otherwise, if the FitsChan contains a keyword of the form
     * CROTAi, where "i" is a single digit, then FITS-AIPS encoding is 
     * used.
     * <br> - Otherwise, if the FitsChan contains a keyword of the form
     * CDELTi, where "i" is a single digit, then FITS-PC encoding is 
     * used.
     * <br> - Otherwise, if the FitsChan contains a keyword of the form
     * CRVALi, where "i" is a single digit, then FITS-WCS encoding is 
     * used.
     * <br> - Otherwise, if the FitsChan contains the "PLTRAH" keyword, then
     * DSS encoding is used,
     * <br> - Otherwise, if none of these conditions is met (as would be the
     * case when using an empty FitsChan), then NATIVE encoding is
     * used.
     * <p>
     * Setting an explicit value for the Encoding attribute always
     * over-rides this default behaviour.
     * <p>
     * Note that when writing information to a FitsChan, the choice of
     * encoding will depend greatly on the type of application you
     * expect to be reading the information in future. If you do not
     * know this, there may sometimes be an advantage in writing the
     * information several times, using a different encoding on each
     * occasion.
     * <h4>The DSS Encoding</h4>
     * The DSS encoding uses FITS header cards to store a multi-term
     * polynomial which relates pixel positions on a digitised
     * photographic plate to celestial coordinates (right ascension and
     * declination). This encoding may only be used to store a single
     * AST Object in any set of FITS header cards, and that Object must
     * be a FrameSet which conforms to the STScI/DSS coordinate system
     * model (this means the Mapping which relates its base and current 
     * Frames must include either a DssMap or a WcsMap with type 
     * AST__TAN or AST__TPN).
     * <p>
     * When reading a DSS encoded Object (using astRead), the FitsChan
     * concerned must initially be positioned at the first card (its
     * Card attribute must equal 1) and the result of the read, if
     * successful, will always be a pointer to a FrameSet. The base
     * Frame of this FrameSet represents DSS pixel coordinates, and the
     * current Frame represents DSS celestial coordinates. Such a read
     * is always destructive and causes the FITS header cards required
     * for the construction of the FrameSet to be removed from the
     * FitsChan, which is then left positioned at the "end-of-file". A
     * subsequent read using the same encoding will therefore not
     * return another FrameSet, even if the FitsChan is rewound.
     * <p>
     * When astWrite is used to store a FrameSet using DSS encoding,
     * an attempt is first made to simplify the FrameSet to see if it
     * conforms to the DSS model.  Specifically, the current Frame must 
     * be a default FK5 SkyFrame; the projection must be a tangent plane 
     * (gnomonic) projection with polynomial corrections conforming to 
     * DSS requirements, and north must be parallel to the second base
     * Frame axis.
     * <p>
     * If the simplification process succeeds, a description of the
     * FrameSet is written to the FitsChan using appropriate DSS FITS
     * header cards. The base Frame of the FrameSet is used to form the
     * DSS pixel coordinate system and the current Frame gives the DSS
     * celestial coordinate system.  A successful write operation will
     * over-write any existing DSS encoded data in the FitsChan, but
     * will not affect other (non-DSS) header cards. If a destructive
     * read of a DSS encoded Object has previously occurred, then an
     * attempt will be made to store the FITS header cards back in
     * their original locations.
     * <p>
     * If an attempt to simplify a FrameSet to conform to the DSS model
     * fails (or if the Object supplied is not a FrameSet), then no
     * data will be written to the FitsChan and astWrite will return
     * zero. No error will result.
     * <h4>The NATIVE Encoding</h4>
     * The NATIVE encoding may be used to store a description of any
     * class of AST Object in the form of FITS header cards, and (for
     * most practical purposes) any number of these Object descriptions
     * may be stored within a single set of FITS cards. If multiple
     * Object descriptions are stored, they are written and read
     * sequentially. The NATIVE encoding makes use of unique FITS
     * keywords which are designed not to clash with keywords that have
     * already been used for other purposes (if a potential clash is
     * detected, an alternative keyword is constructed to avoid the
     * clash).
     * <p>
     * When reading a NATIVE encoded object from a FitsChan (using
     * astRead), FITS header cards are read, starting at the current
     * card (as determined by the Card attribute), until the start of
     * the next Object description is found. This description is then
     * read and converted into an AST Object, for which a pointer is
     * returned. Such a read is always destructive and causes all the
     * FITS header cards involved in the Object description to be
     * removed from the FitsChan, which is left positioned at the
     * following card.
     * <p>
     * The Object returned may be of any class, depending on the
     * description that was read, and other AST routines may be used to
     * validate it (for example, by examining its Class or ID attribute
     * using astGetC). If further NATIVE encoded Object descriptions
     * exist in the FitsChan, subsequent calls to astRead will return
     * the Objects they describe in sequence (and destroy their
     * descriptions) until no more remain between the current card and
     * the "end-of-file".
     * <p>
     * When astWrite is used to write an Object using NATIVE encoding,
     * a description of the Object is inserted immediately before the
     * current card (as determined by the Card attribute).  Multiple
     * Object descriptions may be written in this way and are stored
     * separately (and sequentially if the Card attribute is not
     * modified between the writes). A write operation using the NATIVE
     * encoding does not over-write previously written Object
     * descriptions. Note, however, that subsequent behaviour is
     * undefined if an Object description is written inside a
     * previously-written description, so this should be avoided.
     * <p>
     * When an Object is written to a FitsChan using NATIVE encoding,
     * astWrite should (barring errors) always transfer data and
     * return a value of 1.
     * 
     *
     * @param  encoding   the Encoding attribute of this object
     */
    public void setEncoding( String encoding ) {
       setC( "Encoding", encoding );
    }

    /**
     * Get 
     * digits of precision for floating point FITS values.  
     * This attribute gives the number of significant decimal digits to
     * use when formatting floating point values for inclusion in the
     * FITS header cards within a FitsChan.
     * <p>
     * By default, a positive value is used which results in no loss of
     * information, assuming that the value's precision is double.
     * Usually, this causes no problems.
     * <p>
     * However, to adhere strictly to the recommendations of the FITS
     * standard, the width of the formatted value (including sign,
     * decimal point and exponent) ought not to be more than 20
     * characters. If you are concerned about this, you should set
     * FitsDigits to a negative value, such as -15. In this case, the
     * absolute value (+15) indicates the maximum number of significant
     * digits to use, but the actual number used may be fewer than this
     * to ensure that the FITS recommendations are satisfied. When
     * using this approach, the resulting number of significant digits
     * may depend on the value being formatted and on the presence of
     * any sign, decimal point or exponent.
     * <p>
     * The value of this attribute is effective when FITS header cards
     * are output, either using
     * astFindFits or by the action of the FitsChan's sink function
     * when it is finally deleted.
     * 
     *
     * @return  fitsDigits  this object's FitsDigits attribute
     */
    public int getFitsDigits() {
        return getI( "FitsDigits" );
    }

    /**
     * Set 
     * digits of precision for floating point FITS values.  
     * This attribute gives the number of significant decimal digits to
     * use when formatting floating point values for inclusion in the
     * FITS header cards within a FitsChan.
     * <p>
     * By default, a positive value is used which results in no loss of
     * information, assuming that the value's precision is double.
     * Usually, this causes no problems.
     * <p>
     * However, to adhere strictly to the recommendations of the FITS
     * standard, the width of the formatted value (including sign,
     * decimal point and exponent) ought not to be more than 20
     * characters. If you are concerned about this, you should set
     * FitsDigits to a negative value, such as -15. In this case, the
     * absolute value (+15) indicates the maximum number of significant
     * digits to use, but the actual number used may be fewer than this
     * to ensure that the FITS recommendations are satisfied. When
     * using this approach, the resulting number of significant digits
     * may depend on the value being formatted and on the presence of
     * any sign, decimal point or exponent.
     * <p>
     * The value of this attribute is effective when FITS header cards
     * are output, either using
     * astFindFits or by the action of the FitsChan's sink function
     * when it is finally deleted.
     * 
     *
     * @param  fitsDigits   the FitsDigits attribute of this object
     */
    public void setFitsDigits( int fitsDigits ) {
       setI( "FitsDigits", fitsDigits );
    }

    /**
     * Get 
     * number of FITS header cards in a FitsChan.  
     * This attribute gives the total number of FITS header cards
     * stored in a FitsChan. It is updated as cards are added or
     * deleted.
     * 
     *
     * @return  ncard  this object's Ncard attribute
     */
    public int getNcard() {
        return getI( "Ncard" );
    }

    /**
     * Get 
     * controls the issuing of warnings about various conditions.  
     * This attribute controls the issuing of warnings about selected
     * conditions when an Object is read from or written to a FitsChan.
     * The value supplied for the Warnings attribute should consist of a
     * space separated list of condition names (see the AllWarnings
     * attribute for a list of the currently defined names). Each name 
     * indicates a condition which should be reported. The default 
     * value for Warnings is the string "Tnx Zpx BadCel".
     * <p>
     * The text of any warning will be stored within the FitsChan in the
     * form of one or more new header cards with keyword ASTWARN. If
     * required, applications can check the FitsChan for ASTWARN cards
     * (using astFindFits) after the call to astRead or astWrite has been
     * performed, and report the text of any such cards to the user. ASTWARN
     * cards will be propagated to any output header unless they are
     * deleted from the FitsChan using astDelFits.
     * 
     *
     * @return  warnings  this object's Warnings attribute
     */
    public String getWarnings() {
        return getC( "Warnings" );
    }

    /**
     * Set 
     * controls the issuing of warnings about various conditions.  
     * This attribute controls the issuing of warnings about selected
     * conditions when an Object is read from or written to a FitsChan.
     * The value supplied for the Warnings attribute should consist of a
     * space separated list of condition names (see the AllWarnings
     * attribute for a list of the currently defined names). Each name 
     * indicates a condition which should be reported. The default 
     * value for Warnings is the string "Tnx Zpx BadCel".
     * <p>
     * The text of any warning will be stored within the FitsChan in the
     * form of one or more new header cards with keyword ASTWARN. If
     * required, applications can check the FitsChan for ASTWARN cards
     * (using astFindFits) after the call to astRead or astWrite has been
     * performed, and report the text of any such cards to the user. ASTWARN
     * cards will be propagated to any output header unless they are
     * deleted from the FitsChan using astDelFits.
     * 
     *
     * @param  warnings   the Warnings attribute of this object
     */
    public void setWarnings( String warnings ) {
       setC( "Warnings", warnings );
    }

    /**
     * Get 
     * a list of all currently available condition names.  
     * This read-only attribute is a space separated list of all the conditions
     * names recognized by the Warnings attribute. The names are listed
     * below.
     * <h4>Conditions</h4>
     * The following conditions are currently recognised (all are
     * case-insensitive):
     * <p>
     * <br> - "BadCel": This condition arises when reading a FrameSet from a
     * non-Native encoded FitsChan if an unknown celestial co-ordinate 
     * system is specified by the CTYPE keywords.
     * <p>
     * <br> - "BadLat": This condition arises when reading a FrameSet from a
     * non-Native encoded FitsChan if the latitude of the reference point
     * has an absolute value greater than 90 degrees. The actual absolute
     * value used is set to exactly 90 degrees in these cases.
     * <p>
     * <br> - "NoCTYPE": This condition arises if a default CTYPE value is used 
     * within astRead, due to no value being present in the supplied FitsChan.
     * This condition is only tested for when using non-Native encodings.
     * <p>
     * <br> - "NoEquinox": This condition arises if a default equinox value is used 
     * within astRead, due to no value being present in the supplied FitsChan.
     * This condition is only tested for when using non-Native encodings.
     * <p>
     * <br> - "NoRadesys": This condition arises if a default reference frame is 
     * used for an equatorial co-ordinate system within astRead, due to no 
     * value being present in the supplied FitsChan. This condition is only 
     * tested for when using non-Native encodings.
     * <p>
     * <br> - "NoLonpole": This condition arises if a default value is used for 
     * the LONPOLE keyword within astRead, due to no value being present 
     * in the supplied FitsChan. This condition is only tested for when 
     * using non-Native encodings.
     * <p>
     * <br> - "NoLatpole": This condition arises if a default value is used for 
     * the LATPOLE keyword within astRead, due to no value being present 
     * in the supplied FitsChan. This condition is only tested for when 
     * using non-Native encodings.
     * <p>
     * <br> - "NoMjd-obs": This condition arises if a default value is used for 
     * the date of observation within astRead, due to no value being present 
     * in the supplied FitsChan. This condition is only tested for when using 
     * non-Native encodings.
     * <p>
     * <br> - "Tnx": This condition arises if a FrameSet is read from a FITS
     * header containing an IRAF "TNX" projection which includes terms
     * not supproted by AST. Such terms are ignored and so the resulting
     * FrameSet may be inaccurate.
     * <p>
     * <br> - "Zpx": This condition arises if a FrameSet is read from a FITS
     * header containing an IRAF "ZPX" projection which includes "lngcor" 
     * or "latcor" correction terms. These terms are not supported by AST
     * and are ignored. The resulting FrameSet may therefore be inaccurate.
     * 
     *
     * @return  allWarnings  this object's AllWarnings attribute
     */
    public String getAllWarnings() {
        return getC( "AllWarnings" );
    }

}
