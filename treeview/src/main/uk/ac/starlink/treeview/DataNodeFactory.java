package uk.ac.starlink.treeview;

import java.util.*;
import java.io.*;
import java.text.*;

/**
 * Factory class for constructing {@link DataNode} objects.
 * Instances of this class can be used to construct a <code>DataNode</code> 
 * from a generic input - for instance a <code>String</code> or a 
 * <code>File</code>.
 * It tries to find the most appropriate existing object of one of the
 * classes which implements <code>DataNode</code>.
 * The classes it knows about, in rough order of preference, are:
 * <ul>
 * <li> {@link NDFDataNode}
 * <li> {@link WCSDataNode}
 * <li> {@link ARYDataNode}
 * <li> {@link HistoryDataNode}
 * <li> {@link HDSDataNode}
 * <li> {@link FITSDataNode}
 * <li> {@link XMLDocumentDataNode}
 * <li> {@link XMLElementDataNode}
 * <li> {@link XMLCommentDataNode}
 * <li> {@link XMLTextDataNode}
 * <li> {@link XMLDataNode}
 * <li> {@link ZipFileDataNode}
 * <li> {@link FileDataNode}
 * <li> {@link NdxDataNode}
 * <li> {@link NDArrayDataNode}
 * </ul>
 * The factory will churn out a <code>DataNode</code> object based on
 * the object it is given for construction, the constructors available
 * from the known implementing objects (the above list), and optionally
 * a list of preferences which may be examined and modified using 
 * supplied methods.
 *
 * @author   Mark Taylor (Starlink)
 * @version  $Id$
 */
public class DataNodeFactory implements Cloneable {

    private boolean verbose;
    private PrintStream verbStream;
    private List classList;
    private List tried;
    private List builders;

    private static final Class[] initialClasses = new Class[] {
        NDFDataNode.class,
        WCSDataNode.class,
        ARYDataNode.class,
        HistoryDataNode.class,
        HDSDataNode.class,
        FITSDataNode.class,
        NdxDataNode.class,
        XMLDocumentDataNode.class,
        XMLElementDataNode.class,
        XMLCommentDataNode.class,
        XMLTextDataNode.class,
        XMLDataNode.class,
        ZipFileDataNode.class,
        NDArrayDataNode.class,
        FileDataNode.class
    };

    /**
     * Initialises a new <code>DataNodeFactory</code> with default settings.
     */
    public DataNodeFactory() {
        setNodeClassList( Arrays.asList( initialClasses ) );
    }

    /**
     * Sets the list of preferred classes which this factory should produce.
     *
     * @param  classList  a List of Class objects.  Each of these will 
     *         be turned into a list of DataNodeBuilder objects.
     *         A copy of the list is used.
     */
    public void setNodeClassList( List classList ) {

        /* Store our copy of this list. */
        this.classList = new ArrayList( classList );

        /* Get a corresponding list of builders. */
        this.builders = new ArrayList();
        for ( Iterator cit = classList.iterator(); cit.hasNext(); ) {
            Class clazz = (Class) cit.next();
            DataNodeBuilder[] bbatch = DataNodeBuilder.getBuilders( clazz );
            if ( bbatch.length == 0 ) {
                System.err.println( "No builders from class " + clazz + "?" );
            }
            builders.addAll( Arrays.asList( bbatch ) );
        }
    }

    /**
     * Gets the list of preferred classes which this factory will produce.
     *
     * @return  an array of Classes, each of which implements the 
     *          <code>DataNode</code> interface.  These are the classes which
     *          are searched, in order, for constructors which can generate
     *          a <code>DataNode</code> object when the 
     *          <code>makeDataNode</code> method is called.
     */
    public List getNodeClassList() {
        return Collections.unmodifiableList( classList );
    }

    /**
     * Ensures that the factory will not generate the indicated node type.
     *
     * @param  clazz               a Class to remove from the class list
     */
    public void removeNodeClass( Class clazz ) {
        List clist = classList;
        for ( Iterator it = clist.iterator(); it.hasNext(); ) {
            if ( it.next().equals( clazz ) ) {
                it.remove();
            }
        }
        setNodeClassList( clist );
    }
   
    /**
     * Sets the class you would most like to see generated by the factory.
     *
     * @param   pref                a Class, which must implement the 
     *                              <code>DataNode</code> interface, to be
     *                              used as the preferred object type that
     *                              the <code>makeDataNode</code> method will
     *                              generate.  What this in fact does is to
     *                              push it to the head of the preferred classes
     *                              list (removing it from its current position
     *                              in that list if necessary).
     */
    public void setPreferredClass( Class pref ) {
        removeNodeClass( pref );
        List clist = classList;
        clist.add( 0, pref );
        setNodeClassList( clist );
    }

    /** 
     * Generates a new DataNode from a given object.
     * This looks for constructors in the preferred classes list
     * which take a single argument and tries to construct a new 
     * <tt>DataNode</tt> using each one with a suitable type.
     * Suitable constructors from classes in the class preference list
     * will be tried 
     * in turn until one is successful.  If <code>setVerbose</code> has
     * been called then extensive logging of the constructions tried and
     * why each one failed can be performed.
     *
     * @param   obj                  an object which can be used by one of
     *                               the underlying constructors to generate
     *                               a <code>DataNode</code> object.
     * @return                       a new <code>DataNode</code> object
     * @throws  NoSuchDataException  if no constructor could be found and 
     *                               successfully invoked
     */
    public DataNode makeDataNode( Object obj ) throws NoSuchDataException {
        if ( verbose ) {
            verbStream.println( "\nTrying to construct DataNode from "
                              + obj + ":  " );
        }
        Class objClass = obj.getClass();
        tried = new ArrayList();
        for ( Iterator buildIt = builders.iterator(); buildIt.hasNext(); ) {
            DataNodeBuilder builder = (DataNodeBuilder) buildIt.next();
            if ( builder.suitable( objClass ) ) {
                if ( verbose ) {
                    verbStream.print( "    " + builder );
                }
                DataNode newNode = builder.buildNode( obj );
                if ( newNode != null ) {
                    if ( verbose ) {
                        verbStream.print( "SUCCESS: " + newNode );
                    }
                    newNode.setCreator( 
                        new CreationState( this, builder, obj ) );
                    return newNode;
                }
                tried.add( builder );
            }
        }

        /* Dropped off the end of the loop - no success. */
        throw new NoSuchDataException( 
             "No suitable node could be constructed for " + obj );
    }


    /**
     * Returns a string representation of this factory.
     * The returned string is a comprehensive list of which constructors
     * will be tried.
     *
     * @return  an ordered list of the constructors that the
     *          <code>makeDataNode</code> will try to use.
     */
    public String toString() {
        StringBuffer buf = 
            new StringBuffer( "DataNodeFactory with builders: " );
        for ( Iterator bit = builders.iterator(); bit.hasNext(); ) {
            buf.append( "    " )
               .append( bit.next().toString() )
               .append( '\n' );
        }
        return buf.toString();
    }

  
    /** 
     * Determines whether verbose information about attempted constructions
     * is written.  Output is to standard error.  
     * Intended for debugging purposes.
     *
     * @param  isverb  whether to log information
     */
    public void setVerbose( boolean isverb ) {
        verbose = isverb;
        if ( verbose && verbStream == null ) {
            verbStream = System.err;
        }
    }

    /**
     * Return a list of the classes whose constructors were used in 
     * attempting to construct a DataNode during the last call of
     * <code>makeDataNode</code>.
     *
     * @return  the list of attempted classes
     */
    public List getClassesTried() {
        return tried;
    }

    public Object clone() {
        try {
            DataNodeFactory twin = (DataNodeFactory) super.clone();
            twin.setNodeClassList( classList );
            twin.tried = new ArrayList( tried );
            return twin;
        }
        catch ( CloneNotSupportedException e ) {
            throw new AssertionError();
        }
    }
}
