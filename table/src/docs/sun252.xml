<?xml version='1.0'?>
<!DOCTYPE sun SYSTEM "docs.dtd" [
  <!ENTITY coredocs "http://java.sun.com/j2se/1.4/docs/api/">
  <!ENTITY nbsp     "&#xA0;">
]>

<sun>

<docinfo>

<title>STIL - Starlink Tables Infrastructure Library</title>

<authorlist>
<author>Mark Taylor</author>
</authorlist>

<docnumber>252</docnumber>

<docdate>22 January 2004</docdate>

<contactlist>
<contact>STIL web page:
         <webref url="http://www.star.bris.ac.uk/~mbt/stil/"/></contact>
<contact>Author email:
         <webref url="mailto:m.b.taylor@bristol.ac.uk"
                 >m.b.taylor@bristol.ac.uk</webref></contact>
<contact>Starlink: <webref url="http://www.starlink.ac.uk/"/></contact>
</contactlist>

</docinfo>

<!-- .......................................................... -->
<docbody>
<abstract>

<px>STIL is a set of Java class libraries which allow input,
manipulation and output of tabular data.
As well as an abstract and format-independent definition of what 
constitutes a table, and an extensible framework for "pull-model"
table processing, it provides a number of format-specific
handlers which know how to serialize/deserialize tables; 
amongst others handlers are provided for the VOTable and FITS formats.
The framework for interaction between the core table manipulation
facilities and the format-specific handlers is open and pluggable,
so that handlers for new formats can easily be added.
</px>

<px>The VOTable handling in particular is provided by a high quality 
library which performs efficient XML parsing and can read and 
write VOTables in any of the defined formats (TABLEDATA, BINARY or FITS).
It may be used on its own for VOTable I/O without much reference to
the format-independent parts of the library.
</px>

</abstract>

<sect>
<subhead><title>Introduction</title></subhead>

<p>STIL is a set of class libraries which can do input, output
and manipulation of tables.  It has been developed for use with
astronomical tables, though it could be used for any kind of
tabular data.
It has no "native" external table format.  What it has is 
a model of what a table looks like, 
a set of java classes for manipulating such tables, 
an extensible framework for table I/O, 
and a number of format-specific I/O handlers for dealing with 
several known table formats.
</p>

<p>This document is a programmers' overview of the abilities of the STIL
libraries, including some tutorial explanation and example code.  
Some parts of it may also be useful background reading for users
of applications built on it.
All the classes and methods are not described in detail here;
that information can be found in the <javadoc class=".">javadocs</javadoc>,
which should be read in conjunction with this document if you are 
actually using these libraries.
Much of the information here is repeated in the javadocs.
The hypertext version of this document links to the relevant places
in the javadocs where appropriate.
</p>

<subsect>
<subhead><title>What is a table?</title></subhead>

<p>In words, STIL's idea of what constitutes a table is something
which has the following:
<ul>
<li>Some per-table metadata (parameters)</li>
<li>A number of columns</li>
<li>Some per-column metadata</li>
<li>A number of rows, each containing one entry per column</li>
</ul>
This model is embodied in the
<javadoc class="uk.ac.starlink.table.StarTable"/> interface,
which is described in <ref id="starTable">the next section</ref>.
It maps quite closely, though not exactly, onto the table model
embodied in the <ref id="votable">VOTable</ref> definition, which
itself owes a certain amount to FITS tables.  This is not coincidence.
</p>

</subsect>
</sect>

<sect id="starTable">
<subhead><title>The StarTable interface</title></subhead>

<p>The most fundamental type in the STIL package is 
<javadoc class="uk.ac.starlink.table.StarTable"
         plaintext="uk.ac.starlink.table.StarTable"/>; 
any time you are using a table, you will use an object which 
implements this interface.
</p>

<subsect>
<subhead><title>Table Metadata</title></subhead>

<p>A few items of the table metadata 
(<javadoc class="uk.ac.starlink.table.StarTable" 
          member="getName()">name</javadoc>,
 <javadoc class="uk.ac.starlink.table.StarTable"
          member="getURL()">URL</javadoc>)
are available directly as values from the <code>StarTable</code> interface.
A general parameter mechanism is provided for storing other items,
for instance user-defined ones.
The <javadoc class="uk.ac.starlink.table.StarTable" member="getParameters()"/>
method returns a list of 
<javadoc class="uk.ac.starlink.table.DescribedValue"/>
objects which contain a value and some metadata describing it
(name, units, UCD).  This list can be read or altered as required.
</p>

<p>The <code>StarTable</code> interface also contains
the methods 
<javadoc class="uk.ac.starlink.table.StarTable" member="getColumnCount()"/>
and <javadoc class="uk.ac.starlink.table.StarTable" member="getRowCount()"/>
to determine the shape of the table.  Note however that for tables
with sequential-only access, it may not be possible to ascertain
the number of rows - in this case <code>getRowCount</code> will return -1.
Random-acess tables (see <ref id="tableData"/>) will always return
a positive row count.
</p>
</subsect>

<subsect id="colMeta">
<subhead><title>Column Metadata</title></subhead>

<p>Each column in a <code>StarTable</code> is assumed to contain the
same sort of thing.  More specifically, for each table column there is 
a <javadoc class="uk.ac.starlink.table.ColumnInfo"/> object 
associated with each column which holds metadata describing 
all the values in that column 
(the value associated with that column for each row in the table).
A <code>ColumnInfo</code> contains information about the
<javadoc class="uk.ac.starlink.table.ValueInfo"
         member="getName()">name</javadoc>,
<javadoc class="uk.ac.starlink.table.ValueInfo"
         member="getUnitString()">units</javadoc>,
<javadoc class="uk.ac.starlink.table.ValueInfo"
         member="getUCD()">UCD</javadoc>,
<javadoc class="uk.ac.starlink.table.ValueInfo"
         member="getContentClass()">class</javadoc>
etc of a column, as well as a mechanism for storing additional
('auxiliary') user-defined metadata.
It also provides methods for rendering the values in the column
under various circumstances.
</p>

<p>The class associated with a column, obtained from the 
<javadoc class="uk.ac.starlink.table.ValueInfo"
         member="getContentClass()"/> method, 
is of particular importance.  Every object in the column described
by that metadata should be an instance of the 
<javadoc class="java.lang.Class" docset="&coredocs;"/> 
<code>getContentClass</code>returns
(or of one of its subtypes), or <code>null</code>.
There is nothing in the tables infrastructure which can enforce
this, but a table which doesn't follow this rule is considered broken,
and application code is within its rights to behave unpredictably 
in this case.
Such a broken table might result from a bug in the I/O handler used
to obtain the table in the first place, or a badly-formed table that
it has read, or a bug in one of the wrapper classes upstream from
the table instance being used.
</p>

<p>This class can be anything 
(with the exception of <code>null</code>
and the primitive types like <code>int.class</code>), 
but most table I/O handlers can only
cope with certain types of value - typically those corresponding to
the java primitive classes (numeric and boolean ones) and 
<javadoc class="java.lang.String" docset="&coredocs;"/>s, so these
are the most important ones to deal with.  The contents of a table
cell must always (as far as the access methods are concerned) be
an <javadoc class="java.lang.Object" docset="&coredocs;"/>,
so primitive values cannot be used directly.
The general rule for primitive-like (numeric or boolean) values
is that a scalar should be represented by the appropriate wrapper class
(<javadoc class="java.lang.Integer" docset="&coredocs;"/>,
 <javadoc class="java.lang.Float" docset="&coredocs;"/>,
 <javadoc class="java.lang.Boolean" docset="&coredocs;"/> etc)
and an array by an array of primitives
(<code>int[]</code>,
 <code>float[]</code>,
 <code>boolean[]</code> etc).
Non-primitive-like objects 
(of which <code>String</code> is the most important example)
should be represented by their own class (for scalars) or an array 
of their own class (for arrays).
Note that it is <em>not</em> recommended to use multidimensional arrays
(i.e. arrays of arrays like <code>int[][]</code>);
a 1-dimensional java array should be used, and information about
the dimensionality should be stored in the <code>ColumnInfo</code>'s 
shape attribute.
Thus to store a 3x2 array of integers, a 6-element array of type
<code>int[]</code> would be used, and the <code>ColumnInfo</code>'s
<javadoc class="uk.ac.starlink.table.ValueInfo" member="getShape()"/> 
method would return a two-element array <code>(3,2)</code>.
</p>

</subsect>

<subsect id="tableData">
<subhead><title>Table Data</title></subhead>

<p>The actual data values in a table are considered to be a sequence
of rows, each containing one value for each of the table's columns.
As explained <ref id="colMeta">above</ref>, each such value 
is an <code>Object</code>, and information about its class
(as well as semantic metadata) is available from the column's
<javadoc class="uk.ac.starlink.table.ColumnInfo"/> object.
</p>

<p><code>StarTable</code>s come in two flavours, 
random-acess and sequential-only;
you can tell which one a given table is by using its 
<javadoc class="uk.ac.starlink.table.StarTable" member="isRandom()"/>
method, and how its data can be accessed is determined by this.
In either case, most of the data access methods are declared to
throw an <javadoc class="java.io.IOException" docset="&coredocs;"/>;
this is because the <code>StarTable</code> object may be obtaining
its data from anywhere, for instance reading it directly off disk
on demand, so it needs to have some way to signal an error in 
obtaining the cell data.
</p>

<subsubsect id="sequential">
<subhead><title>Sequential Access</title></subhead>

<p>It is always possible to access a table's data sequentially,
that is starting with the first row and reading forward a row at
a time to the last row; it may or may not be possible to tell
(using <javadoc class="uk.ac.starlink.table.StarTable" member="getRowCount()"/>)
how many rows there are.
To perform sequential access, use the
<javadoc class="uk.ac.starlink.table.StarTable" member="getRowSequence()"/>
method to get a
<javadoc class="uk.ac.starlink.table.RowSequence"/> object,
which is an iterator 
(though not an <javadoc docset="&coredocs;" class="java.util.Iterator"/>)
over the rows in the table.
The <code>RowSequence</code>'s 
<javadoc class="uk.ac.starlink.table.RowSequence" member="next()"/>
method moves forward a row without returning any data;
to obtain the data use either
<javadoc class="uk.ac.starlink.table.RowSequence" member="getCell(int)"/>
or <javadoc class="uk.ac.starlink.table.RowSequence" member="getRow()"/>;
the relative efficiencies of these depend on the implementation, but
in general if you want all or nearly all of the values in a row
it is a good idea to use <code>getRow</code>, if you just want one
or two use <code>getCell</code>.
You cannot move the iterator backwards.
When obtained, a <code>RowSequence</code> is positioned before the
first row in the table, so it is necessary to call <code>next</code>
before the first datum is accessed.
</p>

<p>Here is an example of how to sum the values in one of the numeric columns
of a table.  Since only one value is required from each row,
<code>getCell</code> is used:
<verbatim><![CDATA[
    double sumColumn( StarTable table, int icol ) throws IOException {

        // Check that the column contains values that can be cast to Number.
        Class colClass = table.getColumnInfo( icol );
        if ( ! Number.class.isAssignableFrom( colClass ) ) {
            throw new IllegalArgumentException( "Column not numeric" );
        }

        // Iterate over rows accumulating the total.
        double sum = 0.0;
        for ( RowSequence rseq = table.getRowSequence(); rseq.hasNext(); ) {
            rseq.next();
            Number value = (Number) rseq.getCell( icol );
            sum += value.doubleValue();
        }
        return sum;
    }
]]></verbatim>
The next example prints out every cell value.  Since it needs all the values
in each cell, it uses <code>getRow</code>:
<verbatim><![CDATA[
    void writeTable( StarTable table ) throws IOException {
        int nCol = table.getColumnCount();
        for ( RowSequence rseq = table.getRowSequence(); rseq.hasNext(); ) {
            rseq.next();
            Object[] row = rseq.getRow();
            for ( int icol = 0; icol < nCol; icol++ ) {
                System.out.print( row[ icol ] + "\t" );
            }
            System.out.println();
        }
    }
]]></verbatim>
Note that a tidier representation of the values might be given by
replacing the <code>print</code> call with: 
<verbatim>
    System.out.print( table.getColumnInfo( icol ).formatValue( value, 20 ) + "\t" );
</verbatim>
</p>

</subsubsect>

<subsubsect>
<subhead><title>Random Access</title></subhead>

<p>If a table's 
<javadoc class="uk.ac.starlink.table.StarTable" member="isRandom()"/>
method returns true, then it is possible to access the cells of a 
table in any order.  This is done using the 
<javadoc class="uk.ac.starlink.table.StarTable" member="getCell(long, int)"/>
or <javadoc class="uk.ac.starlink.table.StarTable" member="getRow(long)"/>
methods directly on the table itself.  Similar comments about 
whether to use <code>getCell</code> or <code>getRow</code> apply as
in <ref id="sequential">the previous section</ref>.
</p>

<p>If an attempt is made to call these random access methods 
on a non-random table (one for which <code>isRandom()==false</code>), an
<javadoc class="java.lang.UnsupportedOperationException" docset="&coredocs;"/>
is thrown.
</p>
</subsubsect>

<subsubsect id="randomTable">
<subhead><title>Adapting Sequential to Random Access</title></subhead>

<p>What do you do if you have a sequential-only table and you
need to do random access on it?
The <javadoc class="uk.ac.starlink.table.Tables" 
             member="randomTable(uk.ac.starlink.table.StarTable)"
    >Tables.randomTable</javadoc> utility method
takes any table and returns one which is guaranteed to provide random access.
If the original one is random, it just returns it unchanged,
otherwise it returns a table which contains the same data as the
submitted one, but for which <code>isRandom</code> is guaranteed to
return true.
It effectively does this by taking out a <code>RowSequence</code> and
reading all the data sequentially into some kind of (memory- or disk-based) 
data structure which can provide random access, returning a new 
StarTable object based on that data structure.
</p>

<p>Clearly, this might be an expensive process.  For this reason
it is usually good practice to convert a table to random-access 
at the top level of an application in which random access will be
required at various points, and for general-purpose utility methods
to require random-access tables 
(throwing an exception if they get a sequential-only one).
The alternative practice of utility methods converting argument tables 
to random-access when they are called might result in this 
expensive process happening multiple times.
</p>

<p>Note also that this method may fail from lack of resources when 
attempting to convert a large sequential table to random access.
</p>

</subsubsect>

</subsect>

</sect>

<sect id="io">
<subhead><title>Table I/O</title></subhead>

<p>The table input and output facilities of STIL are handled
by format-specific input and output handlers;
supplied with the package are, amongst others, a VOTable input
handler and output handler, and this means that STIL can read
and write tables in VOTable format.  An input handler is
an object which can turn an external resource into a
<code>StarTable</code> object, and an output handler is one
which can take a <code>StarTable</code> object and store it 
externally in some way.
These handlers are independent components of the system, and
so new ones can be written, allowing all the STIL features
to be used on new table formats without having to make any changes
to the core classes of the library.
</p>

<p>There are two ways of using these handlers.  
You can either use them directly to read in/write out a table 
using a particular format, or you can use the generic I/O facilities
which know about several of these handlers and select an appropriate
one at run time.  The generic reader class is
<javadoc class="uk.ac.starlink.table.StarTableFactory"/>,
and will offer a given stream of bytes to all the handlers it 
knows about until one of them can turn it into a table; 
the generic writer class is
<javadoc class="uk.ac.starlink.table.StarTableOutput"/>,
and will write in a format determined by the filename 
or a format string which might be selected by the user at runtime.
The generic approach is more flexible in a multi-format
environment, but if you know what format you want to deal with
then nothing is gained by using it. 
</p>

<p>By way of example: here is how you can load a table which might be
in any of the supported formats:
<verbatim>
    StarTable table = new StarTableFactory().makeStarTable( filename );
</verbatim>
and here is how you can do it if you know that it's in FITS format:
<verbatim>
    DataSource datsrc = new FileDataSource( filename );
    StarTable table = new FitsTableBuilder().makeStarTable( datsrc, false );
</verbatim>
</p>

<p>The following sections describe in more detail the generic 
input and output facilities, followed by descriptions of each of
the format-specific I/O handlers which are supplied with the package.
There is an additional section (<ref id="jdbc"/>) which deals with
table reading and writing using an SQL database.
</p>


<subsect id="pluggableIO">
<subhead><title>Extensible I/O framework</title></subhead>

<p>STIL can deal with externally-stored tables in a number of different
formats.  It does this using a set of handlers each of which knows
about turning an external table into a java 
<javadoc class="uk.ac.starlink.table.StarTable"/> object 
or turning a <code>StarTable</code> object into an external table.
Such an "external table" will typically be a file on a local disk,
but might also be a URL pointing to a file on a remote host, 
or an SQL query on a remote database, or something else.
</p>

<p>The core I/O framework of STIL itself does not know about any
table formats, but it knows how to talk to format-specific input
or output handlers.  A number of these (VOTable, FITS, ASCII and others)
are supplied as part of the STIL package, so for dealing with
tables in these formats you don't need to do any extra work.
However, the fact that these are treated in a standard way means
that it is possible to add new format-specific handlers and the
rest of the library will work with tables in that format just the
same as with the supplied formats.
</p>

<p>If you have a table format which is unsupported by STIL as it
stands, you can do one or both of the following:
<dl>
<dt>Write a new input handler:</dt>
<dd><p>Implement the <javadoc class="uk.ac.starlink.table.TableBuilder"/>
    interface to take a stream of data and return a
    <code>StarTable</code> object.
    Install it in a 
    <javadoc class="uk.ac.starlink.table.StarTableFactory"/>, which 
    will then be able to pick up tables in this format as well as 
    other known formats.
    Such a <code>TableBuilder</code> 
    can also be used directly to read tables by code which knows
    that it's dealing with data in that particular format.
</p></dd>

<dt>Write a new output handler:</dt>
<dd><p>Implement the <javadoc class="uk.ac.starlink.table.StarTableWriter"/>
    interface to take a <code>StarTable</code> and write it to a given
    destination.
    Install it in a 
    <javadoc class="uk.ac.starlink.table.StarTableOutput"/>, which 
    will be then be able to write tables in this format as well as others.
    Such a <code>StarTableWriter</code>
    can also be used directly to write tables by code which wants to write 
    data in that particular format.
</p></dd>
</dl>
This document does not currently offer a tutorial on writing new table I/O
handlers; read the javadocs for the relevant classes.
</p>

</subsect>

<subsect id="genericInput">
<subhead><title>Generic Table Input</title></subhead>

<p>Obtaining a table from a generic-format external source is done using a 
<javadoc class="uk.ac.starlink.table.StarTableFactory"/>.
The job of this class is to keep track of which input handlers are
registered and to offer an input stream to each of them in turn,
inviting them to turn it into a <code>StarTable</code>.
The basic rule is that you use one of the <code>StarTableFactory</code>'s 
<code>makeStarTable</code> methods to turn what you've got
(e.g. String, URL, <code>DataSource</code>) 
into a StarTable, and away you go.
If no StarTable can be created (for instance because the file named doesn't
exist, or because it is not in any of the supported formats)
then some sort of <code>IOException</code> will be thrown.
Note that if the target stream is compressed in one of the supported 
formats (gzip, bzip2, Unix compress) it will get uncompressed automatically
(the work for this is done by the 
<javadoc class="uk.ac.starlink.util.DataSource"/> class).
</p>

<p>When acquiring a table, you should decide whether you will need to
do random access on it or only sequential access (see <ref id="tableData"/>).
A preference for one or other of these can be indicated to the
<code>StarTableFactory</code> using its 
<javadoc class="uk.ac.starlink.table.StarTableFactory"
         member="setWantRandom(boolean)">wantRandom</javadoc> attribute
(or at construction time).
This gives handlers an opportunity to return different <code>StarTable</code>
implementations which are efficient for different patterns of access,
but note it does <em>not</em> guarantee that tables generated by the factory
will be random-access; see <ref id="randomTable"/> for that.
</p>

<p>Here is a trivial example showing how to read a table file:
<verbatim>
    public StarTable loadTable( File name ) throws IOException {
        return new StarTableFactory().makeStarTable( file.toString() );
    }
</verbatim>
If you want to ensure that the table you get provides random access,
(see <ref id="tableData"/>
you should do something like this:
<verbatim>
    public StarTable loadRandomTable( File name ) throws IOException {
        StarTableFactory factory = new StarTableFactory();
        factory.setWantRandom( true );
        StarTable table = factory.makeStarTable( tile.toString() );
        return Tables.randomTable( table );
    }
</verbatim>
</p>

<p>If you want detailed control over which kinds of tables can be loaded,
you can use the relevant methods of <code>StarTableFactory</code> to
set the exact list of handlers that it uses for table resolution.
Alternatively, you can always bypass <code>StarTableFactory</code> 
and use a particular <javadoc class="uk.ac.starlink.table.TableBuilder"/>
directly.
</p>

</subsect>


<subsect id="genericOutput">
<subhead><title>Generic Table Output</title></subhead>

<p>Generic serialization of tables to external storage is done using a 
<javadoc class="uk.ac.starlink.table.StarTableOutput"/> object.
This has a similar job to the <code>StarTableFactory</code>
described in <ref id="genericInput">the previous section</ref>;
it mediates between code which wants to output a table and a
set of format-specific output handler objects.
The <javadoc class="uk.ac.starlink.table.StarTableOutput"
             member="writeStarTable(uk.ac.starlink.table.StarTable,
                     java.lang.String,
                     java.lang.String)"/> method
is used to write out a <code>StarTable</code> object.
When invoking this method, you specify the location to which 
you want to output the table (usually, but not necessarily, a filename)
and a string specifying the format you would like to write in.
This is usually a short string like "fits" associated with one of
the registered output handlers, but can be other things
(see the javadocs for details).
</p>

<p>Use is very straightforward:
<verbatim>
    void writeTableAsFITS( StarTable table, File file ) throws IOException {
        new StarTableOutput().writeStarTable( table, file.toString(), "fits" );
    }
</verbatim>
If, as in this example, you know what format you want to write the table
in, you could just as easily use the relevant 
<javadoc class="uk.ac.starlink.table.StarTableWriter"/> object directly
(in this case <javadoc class="uk.ac.starlink.fits.FitsTableWriter"/>).
However, doing it with a <code>StarTableOutput</code>
allows users to be offered the choice of which format to use.
</p>

</subsect>

<subsect>
<subhead><title>Supplied Input Handlers</title></subhead>

<p>The table input handlers supplied with STIL are listed in
this section, along with notes on any peculiarities they have in
turning a string into a <code>StarTable</code>.  
As described in <ref id="genericInput"/>, a <code>StarTableFactory</code>
will under normal circumstances recognise a table in any one of these
formats.
</p>

<p>In most cases the string supplied to name the table that 
<code>StarTableFactory</code> should read
is a filename or a URL, referencing a plain or compressed copy of
the stream from which the file is available.
In some cases an additional specifier can be given after a '#' 
character to give additional information about where in that stream
the table is located.
</p>

<subsubsect>
<subhead><title>FITS</title></subhead>

<p>The <javadoc class="uk.ac.starlink.fits.FitsTableBuilder"/> class
can read FITS binary (BINTABLE) and ASCII (TABLE) table extensions.
Unless told otherwise, the first table extension in the named FITS
file will be used.  If the name supplied to the <code>StarTableFactory</code>
ends in a # sign followed by a number however, it means that the
requested table is in the indicated extension of a multi-extension FITS file.
Hence 'spec23.fits#3' refers to the 3rd extension (4th HDU) in the
file spec23.fits.  The suffix '#0' is never used in this context for
a legal FITS file, since the primary HDU cannot contain a table.
</p>

<p>If the table is stored in a FITS binary table extension in a file
on local disk in uncompressed form, then the file will be <em>mapped</em>
rather than read when the <code>StarTable</code> is constructed.
This means that constructing the StarTable is very fast, and a FITS
table of any size can be examined, not limited by available memory.
Subsequent reads may be slower, however, since a read from a mapped
file is done each time.
To foil this behaviour, refer to the file as a URL, for instance
using the designation 'file:spec23.fits' rather than 'spec23.fits'; 
this fools the handler into thinking that the file cannot be mapped,
and it reads it all into memory at once.
</p>

<p>Currently, binary tables are read rather more efficiently than ASCII ones.
ASCII tables are read using Tom McGlynn's 
<webref url="http://heasarc.gsfc.nasa.gov/docs/heasarc/fits/java/v0.9/"
        >nom.tam.fits</webref>,
but BINARY table reading is mostly done using custom code.
</p>
</subsubsect>

<subsubsect>
<subhead><title>VOTable</title></subhead>

<p>The <javadoc class="uk.ac.starlink.votable.VOTableBuilder"/> class
reads VOTables; with a very few exceptions, it ought to handle any table
which conforms to the VOTable 1.0 specification.
In particular, it can deal with data encoded in TABLEDATA, BINARY or FITS 
format.
</p>

<p>A VOTable document is a hierarchical structure which can contain
more than one TABLE element.  By default, the StarTableFactory
will find the first one in the document for you, which in the 
(common) case that the document contains only one table is just
what you want.
If you're after one of the others, identify it with a zero-based 
index number after a '#' sign at the end of the table designation.
So if the following document is called 'cats.xml':
<verbatim><![CDATA[
    <VOTABLE>
      <RESOURCE>
        <TABLE name="Star Catalogue"> ... </TABLE>
        <TABLE name="Galaxy Catalogue"> ... </TABLE>
      </RESOURCE>
    </VOTABLE>
]]></verbatim>
then 'cats.xml' or 'cats.xml#0' refers to the "Star Catalogue" and
'cats.xml#1' refers to the "Galaxy Catalogue".
</p>

<p>Much more detailed information about the VOTable I/O facilities,
which can be used independently of the generic I/O described in
this section, are described in <ref id="votable"/>.
</p>
</subsubsect>

<subsubsect>
<subhead><title>ASCII</title></subhead>

<p>In many cases tables are stored in some sort of unstructured plain
text format, with cells separated by spaces or some other delimiters.
The <javadoc class="uk.ac.starlink.table.formats.TextTableBuilder"/>
class attempts to read these and interpret what's there
in sensible ways, but since there are so
many possibilities of different delimiters and formats for exactly
how values are specified, it won't always succeed.
</p>

<p>The way the text-format table reader is written makes it unsuitable
for reading enormous text-format tables.
</p>

<p>Here are the rules for how the ASCII-format table handler reads tables:
<ul>
<li>Bytes in the file are interpreted as ASCII characters (UTF-8)</li>
<li>Each table row is represented by a single line of text</li>
<li>Lines are terminated by one or more contiguous line termination
    characters: line feed (0x0A) or carriage return (0x0D)</li>
<li>Within a line, fields are separated by one or more whitespace
    characters: space ('&nbsp;') or tab (0x09)</li>
<li>A field is either an unquoted sequence of non-whitespace characters,
    or a sequence of non-newline characters between matching quote
    characters: either single quotes (') or double quotes (")</li>
<li>Within a quoted field, whitespace characters are permitted and are
    treated literally</li>
<li>Within a quoted field, any character preceded by a backslash character
    ('\') is treated literally.  This allows quote characters to appear
    within a quoted string.</li>
<li>An empty quoted string represents the null value</li>
<li>All data lines must contain the same number of fields (this is the
    number of columns in the table)</li>
<li>The data type of a column is guessed according to the fields that
    appear in the table.  If all the fields in one column can be parsed
    as integers (or null values), then that column will turn into an
    integer-type column.  The types that are tried, in order of
    preference, are:
       <code>Boolean</code>,
       <code>Integer</code>,
       <code>Float</code>,
       <code>Double</code>,
       <code>Long</code>,
       <code>String</code>
    </li>
<li>Empty lines are ignored</li>
<li>Anything after a hash character '#' on a line is ignored as far as
    table data goes.  However, lines which start with a '#' at the
    start of the table (before any data lines) will be interpreted
    as metadata as follows:
    <ul>
    <li>The last '#'-starting line before the first data line may contain
        the column names.  If it has the same number of fields as
        there are columns in the table, each field will be taken to be
        the title of the corresponding column.  Otherwise, it will be
        taken as a normal comment line.</li>
    <li>Any comment lines before the first data line not covered by the
        above will be concatenated to form the 'description' parameter
        of the table.</li>
    </ul>
    </li>
</ul>
</p>

<p>If the list of rules above looks frightening, don't worry,
in many cases it ought
to make sense of a table without you having to read the small print.
Here is an example of a suitable ASCII-format table:
<verbatim>
    #
    # Here is a list of some animals.
    #
    # RECNO  SPECIES         NAME         LEGS   HEIGHT/m
      1      pig             "Pigling Bland"  4  0.8
      2      cow             Daisy        4      2
      3      goldfish        Dobbin       ""     0.05
      4      ant             ""           6      0.001
      5      ant             ""           6      0.001
      6      ant             ''           6      0.001
      7      "queen ant"     'Ma\'am'     6      2e-3
      8      human           "Mark"       2      1.8
</verbatim>
In this case it will identify the following columns:
<verbatim>
    Name       Type
    ----       ----
    RECNO      Integer
    SPECIES    String
    NAME       String
    LEGS       Integer
    HEIGHT/m   Float
</verbatim>
It will also use the text "<code>Here is a list of some animals</code>"
as the Description parameter of the table.
Without any of the comment lines, it would still interpret the table,
but the columns would be given the names <code>col1</code>..<code>col5</code>.
</p>

<p>If you understand the format of your files but they don't exactly
match the criteria above, the best thing is probably to write a 
simple free-standing program or script which will convert them 
into the format described here.
You may find Perl or awk suitable languages for this sort of thing.
Alternatively, you could write a new input handler as explained in 
<ref id="pluggableIO"/>.
</p>

</subsubsect>


<subsubsect>
<subhead><title>WDC</title></subhead>

<p>Some support is provided for files produced by the
<webref url="http://www.wdc.rl.ac.uk/">World Data Centre
for Solar Terrestrial Physics</webref>.
The format itself apparently has no name, but files in this format
look something like the following:
<verbatim>
  Column formats and units - (Fixed format columns which are single space seperated.)
  ------------------------
  Datetime (YYYY mm dd HHMMSS)            %4d %2d %2d %6d      -
                                          %1s
  aa index - 3-HOURLY (Provisional)       %3d                  nT

  2000 01 01 000000  67
  2000 01 01 030000  32
      ...
</verbatim>
</p>

<p>The handler class 
<javadoc class="uk.ac.starlink.table.formats.WDCTableBuilder"/> 
is experimental;
it was reverse-engineered from looking at a couple of
data files in the target format, and may not be very robust.
</p>

</subsubsect>


</subsect>

<subsect>
<subhead><title>Supplied Output Handlers</title></subhead>

<p>The table output handlers supplied with STIL are listed in this
section, along with any peculiarities they have in writing a 
<code>StarTable</code> to a destination given by a string 
(usually a filename).
As described in <ref id="genericOutput"/>, a <code>StarTableOutput</code>
will under normal circumstances permit output of a table in any
of these formats.  Which format is used is determined by the 
"format" string passed to 
<javadoc class="uk.ac.starlink.table.StarTableOutput"
         member="writeStarTable(uk.ac.starlink.table.StarTable, 
                                java.lang.String,
                                java.lang.String)"
         >StarTableOutput.writeStarTable</javadoc>
as indicated in the following table; if a null format string
is supplied, the name of the destination string may be used 
to select a format (e.g. a destination ending ".fits" will, unless
otherwise specified, result in writing FITS format).
<verbatim>
    Format string         Format written               Associated file extension
    -------------         --------------               -------------------------
    jdbc                  SQL database
    fits                  FITS binary table              .fits
    votable-tabledata     TABLEDATA-format VOTable       .xml, .vot
    votable-binary-inline Inline BINARY-format VOTable
    votable-binary-href   External BINARY-format VOTable
    votable-fits-inline   Inline FITS-format VOTable
    votable-fits-href     External FITS-format VOTable
    text                  Human-readable plain text      .txt
    html                  Standalone HTML document       .html
    html-element          HTML TABLE element
    latex                 LaTeX tabular environment      .tex
    latex-document        LaTeX freestanding document
    mirage                Mirage input format
</verbatim>
More detail on all these formats is given in the following sections.
</p>

<p>In some cases, more control can be exercised over the exact 
output format by using the format-specific table writers themselves
(these are listed in the following sections), 
since they may offer additional configuration methods.
The only advantage of using a <code>StarTableOutput</code> to mediate
between them is to make it easy to switch between output formats,
especially if this is being done by the user at runtime.
</p>

<subsubsect>
<subhead><title>FITS</title></subhead>

<p>The FITS handler,
<javadoc class="uk.ac.starlink.fits.FitsTableWriter"/>,
will output a two-HDU FITS file; the first
(primary) HDU has no interesting content, and the second one
(the first extension) is of type BINTABLE.
</p>

<p>To write the FITS header for the table extension, certain things
need to be known which may not be available from the <code>StarTale</code>
object being written; in particular the number of rows and the
size of any variable-sized arrays (including variable-length strings)
in the table.  This may necessitate two passes through the data to
do the write.
</p>

<p><code>StarTableOutput</code> will write in FITS format if a
format string "fits" is used, or the format string is null and
the destination string ends in ".fits".
</p>

</subsubsect>

<subsubsect>
<subhead><title>VOTable</title></subhead>

<p>The VOTable handler, 
<javadoc class="uk.ac.starlink.votable.VOTableWriter"/>, 
can write VOTables in a variety of flavours
(see <ref id="voFormats"/>).  In all cases, a <code>StarTableOutput</code>
will write a well-formed VOTable document with a single RESOURCE element
holding a single TABLE element.  The different output formats
(TABLEDATA/FITS/BINARY, inline/href) are determined by configuration
options on the handler instance.  The default handler writes to
inline TABLEDATA format.
</p>

<p>The href-type formats write a (short) XML file and a FITS or binary
file with a similar name 
into the same directory, holding the metadata and bulk data
respectively.  The reference from the one to the other is a relative
URL, so if one is moved, they both should be.
</p>

<p>For more control over writing VOTables, consult <ref id="voOutput"/>.
</p>

</subsubsect>

<subsubsect>
<subhead><title>Plain Text</title></subhead>

<p>The <javadoc class="uk.ac.starlink.table.formats.TextTableWriter"/>
class writes to a simple text-based format which is designed to
be read by humans.  Much of the metadata is ignored, and no reader
exists for this format. 
</p>

<p>Here is an example of a short 3x4 table written in this format:
<verbatim>
    +---------------+---------------+---------------+
    | FLUX          | DELTAX        | DELTAY        |
    +---------------+---------------+---------------+
    | -7.859574E-4  | -7.0277805E-5 | -5.2222218E-5 |
    | -7.4827415E-4 | 3.6666646E-5  | 3.5555564E-5  |
    | 7.4292155E-4  | -4.7500023E-5 | 8.286507E-12  |
    | -7.0536503E-4 | -7.0277805E-5 | -5.2222218E-5 |
    +---------------+---------------+---------------+
</verbatim>
</p>

</subsubsect>

<subsubsect>
<subhead><title>HTML</title></subhead>

<p>The <javadoc class="uk.ac.starlink.table.formats.HTMLTableWriter"/>
class writes tables as HTML 3.2 &lt;TABLE&gt; elements.
According to configuration this may be a freestanding HTML document
or the TABLE element on its own (suitable for incorporation into larger
HTML documents).
</p>

</subsubsect>

<subsubsect>
<subhead><title>LaTeX</title></subhead>

<p>The <javadoc class="uk.ac.starlink.table.formats.LatexTableWriter"/>
class writes tables as LaTeX <code>tabular</code> environments,
either on their own or wrapped in a LaTeX document.
For obvious reasons, this isn't too suitable for tables with very 
many columns.
</p>

</subsubsect>

<subsubsect>
<subhead><title>Mirage</title></subhead>

<p><webref url="http://www.bell-labs.com/project/mirage/"
        hypertext="Mirage"
        plaintext="Mirage (see http://www.bell-labs.com/project/mirage/)"/>
is a powerful standalone tool developed at Bell Labs for analysis
of multidimensional data.  It uses its own file format for input.
The <javadoc class="uk.ac.starlink.mirage.MirageTableWriter"/>
class can write tables in this format.
</p>

</subsubsect>
</subsect>

<subsect id="jdbc">
<subhead><title>I/O using SQL databases</title></subhead>

<p>With appropriate configuration, STIL can read and write
tables from a relational database such as 
<webref url="http://www.mysql.org/">MySQL</webref>.
You can obtain a <code>StarTable</code> which is the result 
of a given SQL query on a database table, 
or store a <code>StarTable</code> as a new table in an existing
database.
Note that this does <em>not</em> allow you to work on the database 'live'.
The classes that control these operations live in the
<javadoc class="uk.ac.starlink.table.jdbc."/> package.
</p>

<p>SQL I/O is handled by slightly different mechanisms than the
other format-specific I/O, but if you are using the generic I/O facilities
you really don't need to worry about that - the generic reader/writer
still does the job of turning a string into a StarTable saving a 
StarTable to a location specified by a string, it's just that
in this case the string represents an SQL query/table rather than
the location of a stream of bytes.
</p>

<p>In the case that a username and/or password is required for use of the
table, and this is not specified in the query URL,
<code>StarTableFactory</code> will arrange to prompt for it.
By default this prompt is to standard output (expecting a response
on standard input), but some other mechanism, for instance a 
graphical one, can be used by modifying the factory's
<javadoc class="uk.ac.starlink.table.StarTableFactory"
         member="getJDBCHander()">JDBCHandler</javadoc>.
</p>

<subsubsect>
<subhead><title>JDBC Configuration</title></subhead>

<p>Java/STIL does not come with the facility to use any particular
SQL database "out of the box"; some additional configuration must
be done before it can work.  This is standard JDBC practice,
as explained in the documentation of the
<javadoc class="java.sql.DriverManager" docset="&coredocs;" 
         plaintext="java.sql.DriverManager"/>
class.
In short, what you need to do is define the 
"<code>jdbc.drivers</code>" system property 
to include the name(s) of the JDBC driver(s) which you wish
to use.  For instance to enable use of MySQL with the Connector/J
database you might start up your JVM with a command line like this:
<verbatim>
    java -classpath /my/jars/mysql-connector-java-3.0.8-stable-bin.jar:myapp.jar
         -Djdbc.drivers=com.mysql.jdbc.Driver 
         my.path.MyApplication
</verbatim>
One gotcha to note is that an invocation like this will not work
if you are using '<code>java&#xa0;-jar</code>' to invoke your application;
if the <code>-jar</code> flag is used then any class path set on
the command line or in the CLASSPATH environment variable or elsewhere
is completely ignored.  This is a consequence of java's security model.
</p>

<p>For both the reader and the writer described below, the string
passed to specify the database query/table may or may not require
additional authentication before the read/write can be carried out.
The general rule is that an attempt will be made to connect with
the database without authentication, and if this fails the user
will be queried for username and password, following which a second
attempt will be made.  If username/password has already been 
solicited, this will be used on subsequent connection attempts.
How the user is queried (e.g. whether it's done graphically or
on the command line) is controlled by the 
<javadoc class="uk.ac.starlink.table.jdbc.JDBCHandler"/>'s 
<javadoc class="uk.ac.starlink.table.jdbc.JDBCAuthenticator"/> object,
which can be set by application code if required.
If generic I/O is being used, you can use the
<code>get/setJDBCHandler</code> methods of the
<javadoc class="uk.ac.starlink.table.StarTableFactory"/> or
<javadoc class="uk.ac.starlink.table.StarTableOutput"/> being used.
</p>

<p>To the author's knowledge, STIL has so far only been used
with the following RDBMSs and drivers:
<dl>
<dt><webref url="http://www.mysql.org/">MySQL</webref></dt>
<dd><p>MySQL 3.23.55 on Linux has been tested with the
    <webref url="http://mirrors.sunsite.dk/mysql/products/connector-j/"
            >Connector/J</webref> driver
    version 3.0.8 and seems to work, though tables with very many columns
    cannot be written owing to SQL statement length restrictions.
    Note there is known to be a column metadata bug in version 3.0.6
    of the driver which can cause a ClassCastException error when
    tables are written.
    </p></dd>
<dt><webref url="http://www.postgresql.org/">PostgreSQL</webref></dt>
<dd><p>PostgreSQL 7.4.1 apparently works with the JDBC driver it comes with.
    Thanks to Jonathan Irwin for writing a patch to make this work.
    </p></dd>
</dl>
Other RDBMSs and drivers ought to work in principle - please let us know
the results of any experiments you carry out.
</p>

</subsubsect>

<subsubsect>
<subhead><title>Reading from a Database</title></subhead>

<p>You can view the result of an SQL query on a relational database as
a table.  This can be done either by passing the query string directly to
a <javadoc class="uk.ac.starlink.table.jdbc.JDBCHandler"/> or
by passing it to the generic
<javadoc class="uk.ac.starlink.table.StarTableFactory"
         member="makeStarTable(java.lang.String)"
         >StarTableFactory.makeStarTable</javadoc>
method (any string starting 'jdbc:' in the latter case is assumed to
be an SQL query string).
The form of this query string is as follows:
<verbatim><![CDATA[
    jdbc:<driver-specific-url>#<sql-query>
]]></verbatim> 
The exact form is dependent on the JDBC driver which is installed.
Here is an example for MySQL:
<verbatim>
    jdbc:mysql://localhost/astro1?user=mbt#SELECT ra, dec FROM swaa WHERE vmag&lt;18
</verbatim>
If the username and/or password are required for the query but are
not specified in the query string, they will be prompted for.
</p>

<p>Note that the StarTable does not represent the JDBC table itself,
but a query on table.  You can get a StarTable representing the
whole JDBC table with a query like <code>SELECT * from table-name</code>,
but this may be expensive for large tables.
</p>


</subsubsect>

<subsubsect>
<subhead><title>Writing to a Database</title></subhead>

<p>You can write out a <code>StarTable</code> as a new table in
an SQL-compatible RDBMS.  Note this will require appropriate access
privileges and may overwrite any existing table of the same name.
The general form of the string which specifies the destination of
the table being written is:
<verbatim><![CDATA[
    jdbc:<driver-specific-url>#<new-table-name>
]]></verbatim>
</p>

<p>Here is an example for MySQL with Connector/J:
<verbatim>
    jdbc:mysql://localhost/astro1?user=mbt#newtab
</verbatim>
which would write a new table called "newtab" in the MySQL database 
"astro1" on the local host with the access privileges of user mbt.
</p>

</subsubsect>

</subsect>

</sect>

<sect>
<subhead><title>GUI Support</title></subhead>

<p>STIL provides a number of facilities to make life easier if you 
are writing table-aware applications which use a graphical user interface.
Most, but not all, of these live in the 
<javadoc class="uk.ac.starlink.table.gui."/> package.
</p>

<subsect>
<subhead><title>Drag and Drop</title></subhead>

<p>Facilities are provided in the generic I/O classes to make 
drag and drop of tables very straightforward.
Dragging is done by clicking down a mouse button on some visual
component (the "drag source") and moving the mouse until it is
over a second component (the "drop target") at which point the
button is released.
The hard work is done by Swing's 
<webref url="http://java.sun.com/j2se/1.4.1/docs/guide/dragndrop/index.html"
        >Drag and Drop</webref> facilities;
STIL provides interfaces between this system and its own generic I/O
facilities so that you can add table transfer into your graphical 
applications with a minimum of effort.
A table is transferred from the drag source to the drop target
by serializing it as an inline VOTable; in this way all the 
data and metadata are transferred without any reference to local
files or other resources, so that it will work between
different JVMs or different hosts just as well as between different
parts of the same application.
</p>

<p>Dragging and dropping are handled separately but in either
case, you will need to construct a new 
<javadoc class="javax.swing.TransferHandler" docset="&coredocs;"
         >javax.swing.TransferHandler</javadoc>
object (subclassing <code>TransferHandler</code> itself and overriding
some methods as below) and install it on the Swing 
<code>JComponent</code> which is to
do be the drag source/drop target using its
<javadoc class="javax.swing.JComponent"
         member="setTransferHandler(javax.swing.TransferHandler)"
         docset="&coredocs;"/> method.
</p>

<p>To allow a Swing component to accept tables that are dropped onto it,
implement <code>TransferHandler</code>'s 
<code>canImport</code> and <code>importData</code>
methods like this:
<verbatim>
    class TableDragTransferHandler extends TransferHandler {
        StarTableFactory factory = new StarTableFactory();

        public boolean canImport( JComponent comp, DataFlavor[] flavors ) {
            return factory.canImport( flavors );
        }

        public boolean importData( JComponent comp, Transferable dropped ) {
            try {
                StarTable table = factory.makeStarTable( dropped );
                processDroppedTable( table );
                return true;
            }
            catch ( IOException e ) {
                e.printStackTrace();
                return false;
            }
        }
    }
</verbatim>
Then any time a table is dropped on that window, the 
<code>processDroppedTable</code> method will be called on it.
</p>

<p>To allow tables to be dragged off of a component, implement
the <code>createTransferable</code> method like this
<verbatim>
    class TableDropTransferHandler extends TransferHandler {
        StarTableOutput writer = new StarTableOutput();

        public int createTransferable( JComponent comp ) {
            StarTable table = getMyTable();
            writer.transferStarTable( table );
        }
    }
</verbatim>
(you may want to override <code>getSourceActions</code> and
<code>getVisualRepresentation</code> as well).
For some Swing components 
(see the
<webref url="http://java.sun.com/j2se/1.4.1/docs/guide/swing/1.4/dnd.html"
        >Swing data transfer documentation</webref>
for a list), 
this is all that is required.
For others, you will need to arrange to recognise the drag gesture
and trigger the <code>TransferHandler</code>'s 
<javadoc class="javax.swing.TransferHandler"
         member="exportAsDrag(javax.swing.JComponent,
                              java.awt.event.InputEvent,
                              int)"
         docset="&coredocs;"/> method as well;
you can use a <javadoc class="uk.ac.starlink.util.gui.DragListener"/> 
for this or see its source code for an example of how to do it.
</p>

<p>If you incorporate one or other of these capabilities into your
application, it will be able to exchange tables with any other
application that does the same.  
<webref url="http://www.starlink.ac.uk/topcat/">TOPCAT</webref>
is an example; you can drag tables off the 'save' toolbar button
or drag them onto the 'load' button.
</p>


</subsect>

<subsect>
<subhead><title>Table Chooser Components</title></subhead>

<p>Some components exist to make it easier to load or save tables:
<dl>

<dt><javadoc class="uk.ac.starlink.table.gui.StarTableChooser"/></dt>
<dd><p>This is for loading tables, and is very much like a
<javadoc class="javax.swing.JFileChooser" docset="&coredocs;"/>,
but it handles turning selected items into a <code>StarTable</code> for you.
</p></dd>

<dt><javadoc class="uk.ac.starlink.table.gui.StarTableNodeChooser"/></dt>
<dd><p>This loads tables as well, and looks similar to the application,
but it presents a more sophisticated interface to the user.
It allows hierarchical browsing of nodes
beyond the directory/file level - for instance you can see the
hierarchical structure of RESOURCE and TABLE elements in a VOTable document,
or the list of HDUs in a FITS file,
and pick the TABLE element that you are interested in.
It uses the same classes as the 
<webref url="http://www.starlink.ac.uk/treeview/">Treeview</webref> 
application to achieve this.
</p></dd>

<dt><javadoc class="uk.ac.starlink.table.gui.StarTableSaver"/></dt>
<dd><p>This also resembles a <code>javax.swing.JFileChooser</code>,
but is used for saving tables.
As well as allowing the user to browse the filesystem and select a
filename, it also allows him/her to select the output file format in
from the list of those which the <code>StarTableOutput</code> 
knows about.
</p></dd>

</dl>
</p>

</subsect>

<subsect>
<subhead><title>SQL Database Interaction</title></subhead>

<p>As explained in <ref id="jdbc"/>,
tables can be read from and written to SQL databases using the 
JDBC framework.  Since quite a lot of information has to be
specified to indicate the details of the table source/destination
(driver name, server host, database name, table name, user authentication
information...) in most cases this requires rather user-unfriendly
URLs to be entered.
For graphical applications, special dialogue components are supplied
which makes this much easier for the user.  These contain
one box per piece of information, so that the user does not need
to remember or understand the JDBC-driver-specific URL.
There are two of these:
<javadoc class="uk.ac.starlink.table.gui.SQLReadDialog"/> for reading
tables and 
<javadoc class="uk.ac.starlink.table.gui.SQLWriteDialog"/>
for writing them.
</p>

</subsect>
</sect>

<sect>
<subhead><title>Processing StarTables</title></subhead>

<p>The <javadoc class="uk.ac.starlink.table."/> package provides
many generic facilities for table processing.
These make heavy use of the "pull-model" of processing, in which
the work of turning one table to another is not done at the time
such a transformation is specified, but only when the table data
is actually required, for instance to write it out to disk as a new
table file or to display it in a GUI component such as a <code>JTable</code>.
One big advantage of this is that calculations which are never used
never need to be done.  Another is that in many cases it means you
can process large tables without having to allocate large amounts of
memory.  For multi-step processes, it is also often faster.
</p>

<subsect>
<subhead><title>Wrap It Up</title></subhead>

<p>The central idea to get used to is that of a "wrapper" table.
This is a table which wraps itself round another one (its "base" table), 
using calls to the base table to provide the basic data/metadata 
but making some some modifications before it returns it to the caller.
Tables can be wrapped around each other many layers deep like an onion.
This is very much like the way that 
<javadoc class="java.io.FilterInputStream" docset="&coredocs;"
         >java.io.FilterInputStream</javadoc>s work.
</p>

<p>Although they don't have to, most wrapper table classes inherit
from <javadoc class="uk.ac.starlink.table.WrapperStarTable"/>.
This is a no-op wrapper, which simply delegates all its calls to
the base table.  
Its subclasses generally leave most of the methods alone, but
override those which relate to the behaviour they want to change.
Here is an example of a very simple wrapper table, which simply
capitalizes it base table's name:
<verbatim>
    class CapitalizeStarTable extends WrapperStarTable {
        public CapitalizeStarTable( StarTable baseTable ) {
            super( baseTable );
        }
        public String getName() {
            return getBaseTable().getName().toUpperCase();
        }
    }
</verbatim>
As you can see, this has a constructor which passes the base table to
the <javadoc class="uk.ac.starlink.table.WrapperStarTable"
             member="WrapperStarTable(uk.ac.starlink.StarTable)"/>
constructor itself, which takes the base table as an argument.
Wrapper tables which do any meaningful wrapping will have to have
a constructor which takes a table, though they may take additional
arguments as well.
More often it is the data which is modified and the metadata which is
left the same - some examples of this are given in <ref id="wrapExamples"/>.
Some wrapper tables wrap more than one table, joining two base tables
to produce a third one which draws data and/or metadata from both.
</p>

<p>The idea of wrappers is used on some components other than 
<code>StarTable</code>s themselves: there are
<javadoc class="uk.ac.starlink.table.WrapperColumn"/>s and
<javadoc class="uk.ac.starlink.table.WrapperRowSequence"/>s as well.
These can be useful in implementing wrapper tables.
</p>

<p>It is a good idea to follow this model when writing your own
processing routines rather than, for instance, doing a calculation
which goes through all the rows of a table calculating new values
and writing them to arrays, then creates a new table based on the arrays.
If you familiarise yourself with the set of wrapper tables supplied
by STIL, hopefully you will often find there are ones there which
you can adapt or use to do much of the work for you.
</p>
</subsect>

<subsect>
<subhead><title>Wrapper Classes</title></subhead>

<p>Here is a list of some of the wrapper classes provided,
with brief descriptions:
<dl>

<dt><javadoc class="uk.ac.starlink.table.ColumnPermutedStarTable"/></dt>
<dd><p>Views its base table with the columns in a different order.
</p></dd>

<dt><javadoc class="uk.ac.starlink.table.RowPermutedStarTable"/></dt>
<dd><p>Views its base table with the rows in a different order.
</p></dd>

<dt><javadoc class="uk.ac.starlink.table.RowSubsetStarTable"/></dt>
<dd><p>Views its base table with only some of the rows showing.
</p></dd>

<dt><javadoc class="uk.ac.starlink.table.RandomWrapperStarTable"/></dt>
<dd><p>Caches a snapshot of its base table's data in a (fast?) 
random-access structure.
</p></dd>

<dt><javadoc class="uk.ac.starlink.table.gui.ProgressBarStarTable"/></dt>
<dd><p>Behaves exactly like its base table, but any RowSequence taken out
on it controls a 
<javadoc class="javax.swing.JProgressBar" docset="&coredocs;"/>, 
so the user can monitor progress in processing a table.
</p></dd>

<dt><javadoc class="uk.ac.starlink.table.ProgressLineStarTable"/></dt>
<dd><p>Like <code>ProgressBarStarTable</code>, but controls an animated
line of text on the terminal for command-line applications.
</p></dd>

<dt><javadoc class="uk.ac.starlink.table.JoinStarTable"/></dt>
<dd><p>Glues a number of tables together side-by-side.
</p></dd>

</dl>
</p>
</subsect>

<subsect id="wrapExamples">
<subhead><title>Examples</title></subhead>

<subsubsect>
<subhead><title>Turn a set of arrays into a StarTable</title></subhead>

<p>Suppose you have three arrays representing a set of points on the plane, 
giving an index number and an x and y coordinate, and you would like
to manipulate them as a StarTable.  One way is to use the 
<javadoc class="uk.ac.starlink.table.ColumnStarTable"/> class,
which gives you a table of a specified number of rows but initially
no columns, to which you can add data a column at a time.
Each added column is an instance of 
<javadoc class="uk.ac.starlink.table.ColumnData"/>;
the <javadoc class="uk.ac.starlink.table.ArrayColumn"/> class
provides a convenient implementation which wraps an array of objects
or primitives (one element per row).
<verbatim>
    StarTable makeTable( int[] index, double[] x, double[] y ) {
        int nRow = new index.length;
        ColumnStarTable table = new ColumnStarTable.makeTableWithRows( nRow );
        table.addColumn( ArrayColumn.makeColumn( "Index", index ) );
        table.addColumn( ArrayColumn.makeColumn( "x", x ) );
        table.addColumn( ArrayColumn.makeColumn( "y", y ) );
        return table;
    }
</verbatim>
</p>

<p>A more general way to approach this is to write a new implementation of
<javadoc class="uk.ac.starlink.table.StarTable"/>.
For this you will usually want to subclass one of the existing 
implementations, probably
<javadoc class="uk.ac.starlink.table.AbstractStarTable"/>,
<javadoc class="uk.ac.starlink.table.RandomStarTable"/> or
<javadoc class="uk.ac.starlink.table.WrapperStarTable"/>.
Here is how it can be done:
<verbatim>
    class PointsStarTable extends RandomStarTable {

        int[] index_;
        double[] x_;
        double[] y_;
        long nRow_;
        ColumnInfo[] colInfos_ = new ColumnInfo[] {
            new ColumnInfo( "index", Integer.class, "point index" ),
            new ColumnInfo( "x", Double.class, "x co-ordinate" ),
            new ColumnInfo( "y", Double.class, "y co-ordinate" ),
        };

        public PointsStarTable( int[] index, double[] x, double[] y ) {
            index_ = index;
            x_ = x;
            y_ = y;
            nRow_ = (long) index_.length;
        }

        public int getColumnCount() {
            return 3;
        }

        public long getRowCount() {
            return nRow_;
        }

        public Object getColumnInfo( int icol ) {
            return colInfos[ icol ];
        }

        public Object getCell( long lrow, int icol ) {
            int irow = checkedLongToInt( lrow );
            switch ( icol ) {
                case 0: return new Integer( index_[ irow ] );
                case 1: return new Double( x_[ irow ] );
                case 2: return new Double( y_[ irow ] );
                default: throw new IllegalArgumentException();
            }
        }
    }
</verbatim>
</p>

</subsubsect>

<subsubsect>
<subhead><title>Improve access efficiency</title></subhead>

<p>If you have a table which is giving slower data access than you
would like (for instance it may be reading data from disk or over
the network, or it may be the result of a long chain of wrapper tables)
you can copy it into a new table which provides its own storage
so that subsequent access is faster.  Of course the contents of the
wrapped table represent a snapshot of the original, and will not
be affected by subsequent changes in the orginal's data.
</p>

<p>The way to do this is to wrap the table in a 
<javadoc class="uk.ac.starlink.table.RandomWrapperStarTable"/>.
<code>RandomWrapperStarTable</code> is an abstract class;
concrete subclasses must provide implementations of its abstract
<javadoc class="uk.ac.starlink.table.RandomWrapperStarTable"
         member="storeNextRow(java.lang.Object[])"/>
and
<javadoc class="uk.ac.starlink.table.RandomWrapperStarTable"
         member="retrieveStoredRow(long)"/>
methods.
Two concrete subclasses are provided:
<javadoc class="uk.ac.starlink.table.RowRandomWrapperStarTable"/>
is better for speed, and
<javadoc class="uk.ac.starlink.table.ColumnRandomWrapperStarTable"/>
is more conservative of memory.
However you can write your own concrete subclasses if you have different
requirements.
</p>

<p>This is in fact the same process as used by 
<javadoc class="uk.ac.starlink.table.Tables"
         member="randomTable(uk.ac.starlink.table.StarTable)"
       >Tables.randomTable</javadoc>,
as described in <ref id="randomTable"/>, and similar caveats apply to it.
</p>
</subsubsect>

</subsect>
</sect>

<sect id="votable">
<subhead><title>VOTable access</title></subhead>

<p>VOTable is an XML-based format for storage and transmission of
tabular data, endorsed by the 
<webref url="http://www.ivoa.net">International Virtual Observatory 
Alliance</webref>.
The DTD and documentation are available from 
<webref url="http://cdsweb.u-strasbg.fr/doc/VOTable/">http://cdsweb.u-strasbg.fr/doc/VOTable/</webref>.
The current version of STIL supports version 1.0 of the format
(with a very few exceptions).
</p>

<p>As with the other handlers tabular data can be read from and
written to VOTable documents using the generic facilities described
elsewhere in this document.  However if you know you're going to be
dealing with VOTables the VOTable-specific parts of
the library can be used on their own; this may be more convenient and
it also allows access to some features specific to VOTables.
</p>

<p>The VOTable functionality is provided in the package
<javadoc class="uk.ac.starlink.votable."/>.
It has the following features:
<ul>
<li>Reads all VOTable data formats</li>
<li>Writes all VOTable data formats</li>
<li>Full access to document structure</li>
<li>Full handling of array types</li>
<li>Flexible table output</li>
<li>Hybrid (SAX/DOM) parsing</li>
<li>Large tables</li>
<li>Fast</li>
<li>Offline parsing</li>
<li>Resolution of relative URLs</li>
<li>Sequential/random access to tabular data</li>
<li>Best efforts parsing of non-conforming documents</li>
</ul>
Most of these are described in subsequent sections.
Many of them, particularly handling of BINARY and FITS format data, 
are at time of writing not believed to be 
available in any other VOTable libraries.
</p>

<p>The following features of the VOTable format are <em>not</em> supported:
<ul>
<li>ID/ref referencing of TABLE, FIELD elements</li>
<li>VOTable 1.1 format GROUP elements</li>
<li>Null value handling for numeric array data types in BINARY/FITS encodings
    <!-- I don't think these really make sense anyway --></li>
</ul>
Additionally the handling of variable-length fields in BINARY streams
is done according to the VOTable 1.1 specification not the VOTable 1.0 one
(probably no table has ever been written using the latter).
</p>

<subsect id='voFormats'>
<subhead><title>Tabular data formats</title></subhead>

<p>The actual table data (cell contents, as opposed to metadata) 
in a VOTable are stored in a TABLE's DATA element.
The VOTable standard allows it to be stored in a number of ways;
It may be present as XML elements in a TABLEDATA element, 
or as binary data in one of two formats, BINARY and FITS;
if binary the data may either be available externally from a given URL
or present in a STREAM element encoded as character data using the
Base64 scheme.
Here are examples of what the different forms of the DATA element look like:
<verbatim>
<![CDATA[
  <!-- TABLEDATA format, inline -->
  <DATA>
    <TABLEDATA>
      <TR> <TD>1.0</TD> <TD>first</TD>  </TR>
      <TR> <TD>2.0</TD> <TD>second</TD> </TR>
      <TR> <TD>3.0</TD> <TD>third</TD>  </TR>
    </TABLEDATA>
  </DATA>

  <!-- BINARY format, inline -->
  <DATA>
    <BINARY>
      <STREAM encoding='base64'>
      P4AAAAAAAAVmaXJzdEAAAAAAAAAGc2Vjb25kQEAAAAAAAAV0aGlyZA==
      </STREAM>
    </BINARY>
  </DATA>

  <!-- BINARY format, to external file -->
  <DATA>
    <BINARY>
      <STREAM href="file:/home/mbt/BINARY.data"/>
    </BINARY>
  </DATA>
]]>
</verbatim>
External files may also be compressed using gzip.
The FITS ones look pretty much like the binary ones, though in the case
of an externally referenced FITS file the file in the URL is a 
fully functioning FITS file with (at least) one TABLE or BINTABLE extension.
</p>

<p>At the time of writing, most VOTables in the wild are written 
in TABLEDATA format.
This has the advantage that it is human-readable, and it's easy 
to write and read using standard XML tools.  However, it is not 
a very suitable format for large tables because of the high
overheads of processing time and storage/bandwidth, especially 
for numerical data.
For efficient transport of large
tables therefore, one of the binary formats is recommended.
</p>

<p>STIL can read and write VOTables in any of these formats.
In the case of reading, you just need to point the library at
a document or TABLE element and it will work out what format the 
table data are stored in and decode them accordingly - the user
doesn't need to know whether it's TABLEDATA or external gzipped FITS
or whatever.
In the case of writing, you can choose which format is used.
</p>
</subsect>

<subsect id='readVotable'>
<subhead><title>Reading VOTables</title></subhead>

<p>STIL offers a number of options for reading a VOTable document,
described below.  In all cases they provide you with a way of
obtaining the table data (contents of the cells) without having to
know how these were encoded.  The API defines the contents of a cell
only as an <code>Object</code>, but to make sense of them, you will
need to have an idea what kind of object each is.
In general, scalars are represented by the corresponding primitive 
wrapper class,
and arrays are represented by an array of primitives of the corresponding
type.  Arrays are only ever one-dimensional - information about any
multidimensional shape they may have is supplied separately
(use the <code>getShape</code> method on the corresponding 
<code>ColumnInfo</code>).
There are a couple of exceptions to this: arrays with 
<code>datatype="char"</code> are represented by String objects
since that is almost always what is intended
(n-dimensional arrays of <code>char</code> are treated as if they were
(n-1)-dimensional arrays of Strings),
and <code>unsignedByte</code> types are represented as if they were 
<code>short</code>s, since in java bytes are always signed.
Complex values are represented just like an array of the corresponding
type but with an extra dimension of size two (the most rapidly varying).
</p>

<p>Here is how all VOTable datatypes are represented then:
<verbatim><![CDATA[
    datatype        Class for arraysize<=1   Class for arraysize>1
    --------        ----------------------   ---------------------
    boolean         Boolean                  boolean[]
    bit             boolean[]                boolean[]
    unsignedByte    Short                    short[]
    short           Short                    short[]
    int             Integer                  int[]
    long            Long                     long[]
    char            Char                     String
    unicodeChar     Char                     String
    float           Float                    float[]
    double          Double                   double[]
    floatComplex    float[]                  float[]
    doubleComplex   double[]                 double[]
]]></verbatim>
</p>

<p>It is not, however, necessary to investigate the values of the
<code>datatype</code> and <code>arraysize</code> attributes to work
out what kinds of objects you are going to get as values of cells
in a table.  Each column of the table object that STIL gives you
can report the class of object which will be found in it.
In most cases, you will receive a 
<javadoc class='uk.ac.starlink.table.StarTable'/> object which contains
the table metadata.  To find the class of objects in the fourth column,
you can do this:
<verbatim>
    Class clazz = starTable.getColumnInfo(3).getContentClass();
</verbatim>
Every object obtained from a cell in that column can be cast to
the class <code>clazz</code> (though note it may also be <code>null</code>).
Useful tip: for generic processing it is often handy to cast scalar 
cell contents to type <javadoc class='java.lang.Number' docset='&coredocs;'/>.
</p>


<subsubsect>
<subhead><title>Read a single VOTable from a file</title></subhead>

<p>The simplest way to read a VOTable is to use 
the generic table reading method described
in <ref id="genericInput"/>, in which you just submit the URL or
filename of a document to a <code>StarTableFactory</code>, 
and get back a <code>StarTable</code> object.  
If you're after one of several TABLE elements in a document,
you can specify this by using a specifying its number as the URL's
fragment ID (the bit after the '#' sign).
</p>

<p>The following code would give you <code>StarTable</code>s
read from the first and fourth TABLE elements in the file "tabledoc.xml":
<verbatim>
    StarTableFactory reader = new StarTableFactory();
    StarTable tableA = reader.makeStarTable( "tabledoc.xml" );
    StarTable tableB = reader.makeStarTable( "tabledoc.xml#3" );
</verbatim>
</p>

<p>If you know it's going to be a VOTable (rather than, e.g., a FITS table)
you could use a <code>VOTableBuilder</code> instead of a 
<code>StarTableFactory</code>, which works in much
the same way, though you need to supply a <code>DataSource</code> 
rather than a URL.  In most cases there is no particular advantage to this.
</p>

<p>In either case, all the data and metadata from the TABLE in the 
VOTable document is available from the resulting <code>StarTable</code> object,
as table parameters, columnInfos or the data itself.
If you are just trying to extract the data and metadata from a 
single TABLE element somewhere in a VOTable document, either of
these methods should be fine.
</p>
</subsubsect>

<subsubsect>
<subhead><title>Read VOTable document structure</title></subhead>

<p>If you are interested in the structure of the VOTable document,
you can obtain a tree of <javadoc class='uk.ac.starlink.votable.VOElement'/>
objects representing all or part of the document (very much like a DOM), 
which can be navigated using the <code>getChildren</code> method and so on.
Some of the nodes in this tree are of specialised subclasses of
VOElement; these nodes provide extra functionality relevant to their
r&#xf4;le in a VOTable document.  
For instance a <code>ParamElement</code> object (which represents 
a PARAM element in the XML document)
has a <code>getObject</code> method, which returns the parameter's
value as a Java object - this may be an <code>Integer</code>,
or a <code>float[]</code> array, or some other type of item, 
depending on not only the <code>value</code> attribute of the element,
but on what its <code>datatype</code> and <code>arraysize</code>
attributes are too (its class follows the same rules as for table columns).
The various VOElement subclasses and their
methods are not documented exhaustively here - see the javadocs.
</p>

<p>The most important of the <code>VOElement</code> 
subclassses is <javadoc class='uk.ac.starlink.votable.TableElement'/>, 
which represents a TABLE element.
The best way to obtain the actual table data (values of the cells) 
from a <code>TableElement</code> 
is to construct a 
<javadoc class='uk.ac.starlink.votable.VOStarTable'/> from it,
which can be interrogated as described elsewhere in this document
to obtain its data and metadata.
The returned <code>StarTable</code> may or may not provide random
access (<code>isRandom</code> may or not return true).
This reflects how the data has been obtained - if it's a binary 
stream from a remote URL it may only be possible to read the rows from
start to finish a row at a time, but if it's a set of DOM nodes 
it may be possible to read cells in any order.
If you need random access for a table and you don't have it 
(or don't know if you do), then use
<javadoc class="uk.ac.starlink.table.Tables"
         member="randomTable(uk.ac.starlink.table.StarTable)"
        >Tables.randomTable</javadoc>
as usual (see <ref id="randomTable"/>).
</p>

<p>It is also possible to access the table data directly (without
making it into a <code>StarTable</code> by using the <code>getData</code>
method of the <code>TableElement</code>, but in this case you need
to work a bit harder to extract some of the data and metadata in
useful forms.  See the <javadoc class='uk.ac.starlink.votable.TabularData'/>
documentation for details.
</p>

<p>Where possible, STIL uses a hybrid SAX/DOM approach to 
constructing the tree of VOElements which represents the VOTable
document.
In general it builds a DOM of the whole document with the exception
of the children of STREAM or TABLEDATA elements, 
since these are the ones which contain the actual table data cells, and 
would thus be likely to have large memory requirements.
When it gets to one of these, it works out how to turn the contents
into a tabular data object, and interprets the corresponding SAX
events directly to do this.  The effect of this is that (for all but
the weirdest VOTable documents) the memory requirements of the DOM tree
are very modest, but all the information about the hierarchical
structure of the document is available.  What's lost from the DOM
is the representation of the cell values themselves, and you almost certainly
don't want to go poking around in that, since you can obtain it
in ready-to-use form from the <code>TableElement</code>.
Having said that, if for some reason you do want the DOM to represent
the whole of a VOTable document, bulk data and all, you can do that
too - just parse the document to construct a DOM yourself, and
submit that full DOM to <code>VOElementFactory</code>.
</p>

<p>Although the DOM tree will be small, in some cases the memory requirements
for a table may be large, since the data has to be stored somewhere.
Currently,
for table data which is supplied inline (in any of the three formats)
STIL will store it internally in some kind of memory structure
(hence random access is available).
There are plans for a configurable flag to cause this data to be stored
in a scratch file instead, so that there is no large memory requirement.
For href-referenced streamed data, it just streams the data every time
the corresponding <code>TabularData</code>'s 
<code>getRowStepper</code> method is called, so in this case only
sequential access is available, and there is no large memory requirement.
</p>

<p>To read a VOTable document as described in this section, use one of 
<javadoc class='uk.ac.starlink.votable.VOElementFactory'/>'s 
several <code>makeVOElement</code> methods to obtain a top-level 
<code>VOElement</code> object.  You can then interrogate the resulting
tree using methods like <code>getChildren</code>, <code>getParent</code>,
<code>getAttribute</code> etc.
When you get to a TABLE element (<code>TableElement</code> object),
turn it into a <code>StarTable</code> using the <code>VOStarTable</code>
adapter class.
The top-level element you get in this way will typically be a 
VOTABLE element, since that is normally the top element of a VOTable
document, but STIL does not require this - for instance the XML document 
could start with a RESOURCE element, or you could use it to 
investigate only a subtree of a DOM representing a document you
parsed earlier.
</p>

<p>Here is an example of using this approach to read the structure
of a, possibly complex, VOTable document.  This program locates each
TABLE element which is the immediate child of the first RESOURCE
element in the document, and prints out its column titles and 
table data.
<verbatim><![CDATA[
    // Create a tree of VOElements from a named XML file.
    VOElement top = VOElementFactory.makeVOElement( "testVot.xml" );

    // Find the first RESOURCE element.
    VOElement[] resources = top.getDescendantsByName( "RESOURCE" );
    VOElement res1 = resources[ 0 ];

    // Iterate over all its direct children which are TABLE elements.
    VOElement[] tables = res1.getChildrenByName( "TABLE" );
    for ( int iTab = 0; iTab < tables.length; iTab++ ) {
        System.out.println( "Table #" + iTab + "\n\n" );
        TableElement tableEl = (TableElement) tables[ iTab ];
        StarTable starTable = new VOStarTable( tableEl );

        // Write out the column name for each of its columns.
        int nCol = starTable.getColumnCount();
        for ( int iCol = 0; iCol < nCol; iCol++ ) {
            System.out.print( starTable.getColumnInfo( iCol ).getName() + "\t" );
        }
        System.out.println();

        // Iterate through its data rows, printing out each element.
        for ( RowSequence rSeq = starTable.getRowSequence(); rSeq.hasNext(); ) {
            rSeq.next();
            Object[] row = rSeq.getRow();
            for ( int iCol = 0; iCol < nCol; iCol++ ) {
                System.out.print( row[ iCol ] + "\t" );
            }
            System.out.println();
        }
    }
]]></verbatim>
</p>
</subsubsect>

<subsubsect>
<subhead><title>Streamed access</title></subhead>

<p>If you only need one-shot access to the data in a single TABLE element,
you can use instead the 
<javadoc class="uk.ac.starlink.votable.VOTableBuilder" 
         member="streamStarTable(java.io.InputStream,
                                 uk.ac.starlink.table.StarTable,
                                 java.lang.String)"/> 
method of <code>VOTableBuilder</code>, which effectively turns a 
stream of bytes containing a VOTable document into a stream of 
events representing a table's metadata and data.  You define how these events
are processed by writing an implementation of the 
<javadoc class='uk.ac.starlink.table.TableSink'/> interface.
This builds a very minimal DOM (only the parents of the TABLE element
you're after) and obtains the table data directly from SAX events,
so it is very fast and has a tiny memory footprint.
Since it bails out as soon as it has transmitted the table it's after,
it may even be able to pull table data out of a stream which is not valid XML.
</p>

<p>The following code streams a table and prints out the name of 
the first column and the average of its values (assumed numerical):
<verbatim>
    // Set up an object to handle table processing callback events.
    TableSink sink = new TableSink() {

        long count;  // number of rows
        double sum;  // running total of values from first column

        // Handle metadata by printing out the first column name.
        public void acceptMetadata( StarTable meta ) {
            String name1 = meta.getColumnInfo( 0 ).getName();
            System.out.println( "First column name: " + name1 );
        }

        // Handle a row by updating running totals.
        public void acceptRow( Object[] row ) {
            sum += ((Number) row[ 0 ]).doubleValue();
            count++;
        }

        // Handle end-of-table event by writing summary.
        public void endRows() {
            System.out.println( "First column average: " + sum / count );
        }
    };

    // Stream the named file to the sink we have defined, getting the data
    // from the first TABLE element in the file.
    InputStream strm = new FileInputStream( "myVot.xml" );
    new VOTableBuilder().streamStarTable( strm, sink, 0 );
    strm.close();
</verbatim>
</p>

</subsubsect>
</subsect>

<subsect id="voOutput">
<subhead><title>Writing VOTables</title></subhead>

<p>To write a VOTable using STIL you have to prepare a 
<javadoc class='uk.ac.starlink.table.StarTable'/> 
object which defines the output table's metadata and data.  
The <code>uk.ac.starlink.table</code> package
provides a rich set of facilities for creating and modifying these,
as described elsewhere in this document. 
In general the FIELD arraysize and datatype attributes are determined
from column classes using the same mappings described in 
<ref id='readVotable'/>.
</p>

<p>A range of facilities for writing StarTables out as VOTables
is offered, allowing control over the data format and the structure
of the resulting document.
</p>

<subsubsect>
<subhead><title>Generic table output</title></subhead>

<p>Depending on your application, you may wish to provide the option of
output to tables in a range of different formats including VOTable.  
This can be easily done using the generic output facilities described in 
<ref id="genericOutput"/>.
</p>
</subsubsect>


<subsubsect>
<subhead><title>Single VOTable output</title></subhead>

<p>The simplest way to output a table in VOTable format is to
use a <javadoc class='uk.ac.starlink.votable.VOTableWriter'/>.
This can be configured/constructed to write its output in any of
the formats described in <ref id='voFormats'/> (TABLEDATA,
inline FITS etc).  This will write an XML document containing
a single TABLE within a single RESOURCE within a top-level VOTABLE 
element.  In the case of streamed output which is not inline,
the streamed (BINARY or FITS) data will be written to a new file
with a name similar to that of the main XML output file.
</p>

<p>Assuming that you already have your StarTable
to output, here is how you could write it out in all the possible
formats:
<verbatim>
    void outputAllFormats( StarTable table ) throws IOException {
        VOTableWriter voWriter = new VOTableWriter( DataFormat.TABLEDATA, true );
        voWriter.writeStarTable( table, "tabledata-inline.xml" );

        voWriter.setDataFormat( DataFormat.FITS );
        voWriter.writeStarTable( table, "fits-inline.xml" );

        voWriter.setDataFormat( DataFormat.BINARY );
        voWriter.writeStarTable( table, "binary-inline.xml" );

        voWriter.setInline( false );
        voWriter.setDataFormat( DataFormat.FITS );
        voWriter.writeStarTable( table, "fits-href.xml" );

        voWriter.setDataFormat( DataFormat.BINARY );
        woWriter.writeStarTable( table, "binary-href.xml" );
    }
</verbatim>
</p>
</subsubsect>

<subsubsect>
<subhead><title>TABLE element output</title></subhead>

<p>You may wish to write a VOTable document with a more complicated
structure than a simple VOTABLE/RESOURCE/TABLE one.  In this case
you can use the <javadoc class='uk.ac.starlink.votable.VOSerializer'/>
class which handles only the output of TABLE elements themselves
(the hard part), leaving you free to embed these in whatever XML
superstructure you wish.
</p>

<p>Once you have obtained your <code>VOSerializer</code> by specifying
the table it will serialize and the data format it will use, 
you should invoke its <code>writeFields</code> method followed by
either <code>writeInlineDataElement</code> or 
<code>writeHrefDataElement</code>.
For inline output, the output should be sent to the same stream 
to which the XML itself is written.  In the latter case however, 
you can decide where the streamed data goes, allowing possibilities such
as sending it to a separate file in a location of your choosing,
creating a new MIME attachment to a message, or sending it down
a separate channel to a client.  In this case you will need to
ensure that the href associated with it (written into the STREAM element's
<code>href</code> attribute) will direct a reader to the right place.
</p>

<p>Here is an example of how you could write two inline tables 
in the same RESOURCE element:
<verbatim><![CDATA[
    void writeTables( StarTable t1, StarTable t2 ) {
        BufferedWriter out = 
            new BufferedWriter( new OutputStreamWriter( System.out ) );

        out.write( "<VOTABLE version='1.0'>\n" );
        out.write( "<RESOURCE>\n" );
        out.write( "<DESCRIPTION>Two tables</DESCRIPTION>\n" );

        out.write( "<TABLE>\n" );
        VOSerializer ser1 = VOSerializer.makeSerializer( DataFormat.TABLEDATA, t1 );
        ser1.writeFields( out );
        ser1.writeInlineDataElements( out );
        out.write( "</TABLE>\n" ):

        out.write( "<TABLE>\n" );
        VOSerializer ser2 = VOSerializer.makeSerializer( DataFormat.TABLEDATA, t2 );
        ser2.writeFields( out );
        ser2.writeInlineDataElements( out );
        outStream.write( "</TABLE>\n" );
        outStream.write( "</RESOURCE>\n" );
        outStream.write( "</VOTABLE>\n" );
    }
]]></verbatim>
and here is how you could write a table with its data streamed to a 
binary file with a given name (rather than the automatically chosen
one selected by <code>VOTableWriter</code>):
<verbatim><![CDATA[
    void writeTable( StarTable table, File binaryFile ) {
        BufferedWriter out = 
            new BufferedWriter( new OutputStreamWriter( System.out ) );

        out.write( "<VOTABLE version='1.0'>\n" );
        out.write( "<RESOURCE>\n" );
        out.write( "<TABLE>\n" );
        VOSerializer ser = VOSerializer.makeSerializer( DataFormat.BINARY, table );
        ser.writeFields( out );
        DataOutputStream binOut = 
            new DataOutputStream( new FileOutputStream( binOut ) );
        ser.writeHrefDataElement( out, "file:" + binaryFile, binOut );
        binOut.close();
        out.write( "</TABLE>\n" );
        out.write( "<RESOURCE>\n" );
        out.write( "<VOTABLE>\n" );
    }
]]></verbatim>
</p>

</subsubsect>

</subsect>

</sect>

<sect>
<subhead><title>Table Tools</title></subhead>

<p>A couple of applications using the STIL library currently exist,
as listed below.  More will be made available in the future,
either bundled with STIL or in separate application packages.
</p>

<subsect>
<subhead><title>Tablecopy</title></subhead>

<p>Tablecopy copies a table from any of the (input-) supported formats
into any of the (output-) supported ones.
This is pretty trivial, since all the hard work is done using the
generic I/O facilities described in <ref id="io"/>.
</p>

<p>The application is the <code>main</code> method of 
<javadoc class="uk.ac.starlink.table.TableCopy"/>, though it may be
moved in future releases.
Invoking it with the "-help" flag will print a usage message.
Assuming STIL is on your classpath:
<verbatim><![CDATA[
    java uk.ac.starlink.table.TableCopy -help
       Usage: TableCopy [-ofmt <out-format>] <in-table> <out-table>

       Known formats:
          jdbc
          fits
          votable-tabledata
          votable-binary-inline
          votable-binary-href
          votable-fits-inline
          votable-fits-href
          text
          html
          html-element
          latex
          latex-document
          mirage
]]></verbatim>
which should be fairly self-explanatory.
According to how you have downloaded STIL you may also be able to
invoke it using the "<code>tablecopy</code>" script.
For some, though not all, output formats, using "-" as the 
<code>out-table</code> argument will write to standard output.
You can't use the same trick for standard input I'm afraid.
</p>

<p>Here are some examples of use:
<ul>
<li>Copy a FITS table to a VOTable:
<verbatim>
    tablecopy stars.fits stars.xml
</verbatim>
</li>
<li>Print the contents of the fifth &lt;TABLE&gt; element in a VOTable
document to standard output in human-readable format:
<verbatim>
    tablecopy -ofmt text vizier.xml#4 -
</verbatim>
</li>
<li>Write the results of an SQL query on a MySQL database
to a FITS binary table:
<verbatim>
   java -Djdbc.drivers=com.mysql.jdbc.Driver
        -classpath topcat-full.jar:mysql-connector-java-3.0.6-stable-bin.jar
        uk.ac.starlink.table.TableCopy
        -ofmt fits
        "jdbc:mysql://localhost/astro1#SELECT ra, dec, Imag, Kmag FROM dqc"
        wfslist.cat
</verbatim>
</li>
</ul>
</p>

</subsect>

<subsect>
<subhead><title>TOPCAT</title></subhead>

<p><webref url="http://www.starlink.ac.uk/topcat/">TOPCAT</webref>
(Tool for OPerations on Catalogues And Tables) is a graphical
application for interactive manipulation of tables, written by
the same author as STIL.
All its table I/O and processing is built on STIL.
</p>
</subsect>

</sect>

<sect>
<subhead><title>Acknowledgements</title></subhead>
</sect>

<sect>
<subhead><title>Release Notes</title></subhead>

<p>Prior to version 1.0 of this release, these routines were available
in the TABLE and VOTABLE packages of the Starlink java set.
Although much of the code remains the same, there have been 
quite a number of incompatible API-level changes since that version.
The author would be happy to help people who used the old version
and want help adapting their code to the current STIL release.
</p>

<p>Since this is the first proper public release we hope that future 
releases will provide a much better degree of API-level backward 
compatibility, but no guarantee is offered that no incompatible
changes will be made in the future.
</p>

<p>STIL is released under the terms of the 
<webref url="http://www.gnu.org/copyleft/gpl.html"
        plaintext="GNU General Public License 
                   (see http://www.gnu.org/copyleft/gpl.html)"
        >GNU General Public License</webref>.
</p>

</sect>

</docbody>
</sun>
