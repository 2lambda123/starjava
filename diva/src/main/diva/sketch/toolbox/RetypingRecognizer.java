/*
 * $Id: RetypingRecognizer.java,v 1.1 2000/05/10 21:55:47 hwawen Exp $
 *
 * Copyright (c) 1998 The Regents of the University of California.
 * All rights reserved.  See the file COPYRIGHT for details.
 */
package diva.sketch.toolbox;

import diva.sketch.recognition.StrokeRecognizer;
import diva.sketch.recognition.StrokeRecognition;
import diva.sketch.recognition.StrokeRecognitionSet;
import diva.sketch.recognition.TimedStroke;
import diva.sketch.recognition.Type;
import diva.sketch.recognition.SimpleData;

import java.util.HashMap;
import java.util.Iterator;

/**
 * FIXME
 *
 * @author Michael Shilman  (michaels@eecs.berkeley.edu)
 * @version $Revision: 1.1 $
 * @rating Red
 */
public class RetypingRecognizer implements StrokeRecognizer {
    /**
     * The recognizer that performs low-level recognition on strokes.
     */
    StrokeRecognizer _llr;

    /**
     * The set of types that are allowed through.
     */
    HashMap _allowedTypes;
    
    /**
     * Construct a filter recognizer which uses the given recognizer to
     * perform its low-level recognition.
     */
    public RetypingRecognizer(StrokeRecognizer llr){
        _llr = llr;
        _allowedTypes = new HashMap();
    }

    /**
     * Add a type that is allowed through by this filter
     * recognizer.  FIXME
     */
    public void addAllowedType(String allowedType, String mappedType) {
        _allowedTypes.put(allowedType, mappedType);
    }

    /**
     * Add a type that is allowed through by this filter
     * recognizer.  FIXME
     */
    public void addAllowedType(String allowedType) {
        _allowedTypes.put(allowedType, allowedType);
    }
    
    /**
     * Debugging output.
     */
    private void debug(String s) {
        System.err.println(s);
    }

    /**
     * Take a recognition set generated by the LLR and see whether or
     * not it contains some allowed types with non-zero confidences.
     * If so, return a StrokeRecognitionSet that contains the recognitions
     * of these allowed types.  If not, return NO_RECOGNITION.
     */
    protected StrokeRecognitionSet filterTypes(StrokeRecognitionSet in) {
        StrokeRecognitionSet out = StrokeRecognitionSet.NO_RECOGNITION;
        for(Iterator rs = in.recognitions(); rs.hasNext(); ) {
            StrokeRecognition rin = (StrokeRecognition)rs.next();
            String mappedID = (String)_allowedTypes.get(rin.getType().getID());
            if(mappedID != null && rin.getConfidence() > 0) {
                if(out == StrokeRecognitionSet.NO_RECOGNITION) { //lazy allocation
                    out = new StrokeRecognitionSet();
                }
                if(mappedID.equals(rin.getType().getID())) {
                    out.addRecognition(rin);
                }
                else {
                    out.addRecognition(new StrokeRecognition(new SimpleData(mappedID),
															 rin.getConfidence()));
                }
            }
        }
        return out;
    }

    /**
     * Remove a type that is allowed through by this filter
     * recognizer.
     */
    public void removeAllowedType(String typeID) {
        _allowedTypes.remove(typeID);
    }
    
    /**
     * Perform filtered recognition based on the LLR's
     * recognition on the stroke.
     */
    public StrokeRecognitionSet strokeCompleted(TimedStroke s) {
        return filterTypes(_llr.strokeCompleted(s));
    }

    /**
     * Perform filtered recognition based on the LLR's
     * recognition on the stroke.
     */
    public StrokeRecognitionSet strokeModified(TimedStroke s) {
        return filterTypes(_llr.strokeModified(s));
    }

    /**
     * Perform filtered recognition based on the LLR's
     * recognition on the stroke.
     */
    public StrokeRecognitionSet strokeStarted(TimedStroke s) {
        return filterTypes(_llr.strokeStarted(s));
    }
}

