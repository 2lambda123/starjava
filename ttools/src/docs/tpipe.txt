TablePipe
=========

TablePipe is like TableCopy, but does processing on the table as well.

This is very sketchy documentation for the TablePipe utility. 

TABLEPIPE IS ALPHA SOFTWARE.  Use at your own risk (but please let
me know of any problems).


Invocation
----------

To run TablePipe use something like:

   java -jar tpipe.jar <args>
   java -classpath ttools.jar uk.ac.starlink.ttools.TablePipe <args>
   <starjava>/bin/tpipe <args>


Help
----

The -h flag gives usage information; this is the main reference documentation
currently available.  In case of conflict with these notes, the -h 
output is probably correct.


Arguments
---------

TablePipe has three main sets of arguments: input table specifier, 
processing specifiers, and mode specifier.  Think of it like a
unix pipeline, with the table starting at the left (as specified
with the input table specifier), progressing through processing
stages in order as specified by the processing specifiers, and
ending up at the mode specifier which does something with the
processed table.


   Input Specifier
   ---------------

   Input specifier has the form:

       [-ifmt <in-format> [-stream]] [<in-table>]
   
   -ifmt <in-format>
      <in-format> is the name of one of the input formats.  If the 
      -ifmt flag is not used, auto format-detection is used 
      (OK for FITS and VOTables).  For other formats, such as CSV 
      or ASCII, you must name a format using this flag.

   -stream
      This flag can be specified to ensure that the input table is read
      as a stream.  You need the -ifmt flag in this case.  Depending 
      on the required operations and processing mode, this may fail 
      (sometimes you need to read the input file more than once).

   <in-table>
      Names the input table.  May be "-" to specify standard input
      (in which case -stream is implicit).


   Mode Specifier
   --------------

   One of the following should be specified to determine what happens 
   to the table at the end of the pipeline:

   -write [-ofmt <out-format>] [-o <out-table>]
      A new table is written.  If the -o flag is specified, it's written
      to the named file, otherwise it's streamed to standard output.
      The output format is named using the -ofmt flag; if not supplied,
      an attempt is made to guess the format from the destination name.
      If neither -o nor -ofmt is specified, it's written in text format
      to standard output.

   -tosql <jdbc-url> [-user <username>] [-password <password>]
      A new table is written to an SQL database.  You need the appropriate
      JDBC drivers and -Djdbc.drivers set as usual.
      You can specify your SQL connection username and password or not -
      you will be prompted on the terminal if they are required.

   -meta
      Prints to standard output the table metadata: parameters and
      column names 

   -count
      Counts the number of rows and columns and writes the answers to
      standard output.

  
   Processing Specifiers
   ---------------------

   You can use any combination of these, they will be processed in order
   like a unix pipeline.  Each operates on its input table to produce
   an output table.

   -select <expr>
      Include in the output table only rows for which the given expression
      <expr> evaluates to true.  The syntax is like in TOPCAT.  Columns
      can be addressed by name (if the name is syntactically a java 
      identifier) case-independently, or as $n, where n is the column
      index.  $1 is the first column.  $0 is the row index (starting at 1).

   -every <step>
      Include only every <step>'th row, starting with the first row.

   -head <nrows>
      Include only the first <nrows> rows of the table.

   -addcol [-after <col-id> | -before <col-id>] <col-name> <expr>
      Add a new column called <col-name> defined by the algebraic expression
      <expr>.  Expression syntax is as for the -select flag.  By default
      the new row appears after the last row of the table, but you
      can position it using either the -after or -before flags.  In either
      case, identify a column using its name (if it is syntactically
      a java identifier), or its number (the first column is 1), or
      its $identifier ($1 is the first column).

   -keepcols <colid-list>
      Output table consists of only those columns named in <colid-list>,
      in that order.  <colid-list> is space-separated.  Column identifier
      syntax is as for -addcol flag.

   -delcols <colid-list>
      Delete named columns.  <colid-list> is as for -keepcols flag.

   -explode
      Turns any column which is an N-element array into N scalar columns.


Examples
--------

   tpipe -head 5 -write cat.fits

      Outputs the first 5 rows of cat.fits to standard output in 
      human-readable form.

   tpipe -ifmt csv xxx.csv -keepcols "index ra dec" -write -ofmt fits xxx.fits

      Copies a comma-separated value file to a FITS file using only 
      the three columns INDEX, RA and DEC.

   cat tab1.vot | tpipe - -addcol IV_SUM "(IMAG+VMAG)" \
                          -addcol IV_DIFF "(IMAG-VMAG)" \
                          -delcols "IMAG VMAG" \
                          -write - > tab2.vot

      Replaces two columns by their sum and difference in a VOTable.

   tpipe t.fits -meta

      Outputs column and table metadata about t.fits.

   tpipe survey.fits -select "skyDistance(hmsToRadians(RA),dmsToRadians(DEC),
                                          0.6457,-0.1190) < 5 * ARC_MINUTE" \
                     -count

      Counts the number of rows within a given cone of sky.

   tpipe -explode x.fits -tosql jdbc:mysql://localhost/astro1#TABLEX

      Writes a FITS table to an SQL table, converting any array columns 
      to scalar ones.

 
- Mark Taylor (m.b.taylor@bristol.ac.uk)
