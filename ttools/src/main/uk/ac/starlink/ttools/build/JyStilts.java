package uk.ac.starlink.ttools.build;

import java.io.BufferedWriter;
import java.io.IOException;
import java.io.OutputStream;
import java.io.Writer;
import java.lang.reflect.Array;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.StringTokenizer;
import org.xml.sax.SAXException;
import uk.ac.starlink.table.StarTable;
import uk.ac.starlink.table.StarTableFactory;
import uk.ac.starlink.table.StarTableOutput;
import uk.ac.starlink.table.WrapperRowSequence;
import uk.ac.starlink.table.WrapperStarTable;
import uk.ac.starlink.task.Task;
import uk.ac.starlink.ttools.Formatter;
import uk.ac.starlink.ttools.Stilts;
import uk.ac.starlink.ttools.filter.ProcessingFilter;
import uk.ac.starlink.ttools.filter.StepFactory;
import uk.ac.starlink.ttools.task.ConsumerTask;
import uk.ac.starlink.ttools.task.MapEnvironment;
import uk.ac.starlink.util.LoadException;
import uk.ac.starlink.util.ObjectFactory;

/**
 * Writes a Jython module which facilitates use of STILTS functionality
 * from Jython.
 * The <code>main</code> method will write the jython source code
 * to standard output.
 *
 * @author   Mark Taylor
 * @since    12 Feb 2010
 */
public class JyStilts {

    private final Stilts stilts_;
    private final Formatter formatter_;
    private final Map clazzMap_;
    private final String[] imports_;

    /** Java classes which are used by python source code. */
    private static final Class[] IMPORT_CLASSES = new Class[] {
        java.lang.reflect.Array.class,
        java.util.ArrayList.class,
        uk.ac.starlink.table.StarTable.class,
        uk.ac.starlink.table.StarTableFactory.class,
        uk.ac.starlink.table.StarTableOutput.class,
        uk.ac.starlink.table.WrapperStarTable.class,
        uk.ac.starlink.table.WrapperRowSequence.class,
        uk.ac.starlink.ttools.Stilts.class,
        uk.ac.starlink.ttools.filter.StepFactory.class,
        uk.ac.starlink.ttools.task.MapEnvironment.class,
    };

    /**
     * Constructor.
     *
     * @param  stilts  stilts instance defining available tasks etc
     */
    public JyStilts( Stilts stilts ) {
        stilts_ = stilts;
        formatter_ = new Formatter();
        clazzMap_ = new HashMap();
        Class[] clazzes = IMPORT_CLASSES;
        imports_ = new String[ clazzes.length ];
        for ( int ic = 0; ic < clazzes.length; ic++ ) {
            Class clazz = clazzes[ ic ];
            String importName = clazz.getName();
            imports_[ ic ] = "import " + importName;
            clazzMap_.put( clazz, importName );
        }
    }

    /**
     * Generates python source giving module header lines.
     *
     * @return  python source code lines
     */
    private String[] header() {
        return new String[] {
            "'''stilts allows access to STILTS commands.",
            "",
            "See the manual, http://www.starlink.ac.uk/stilts/sun256/",
            "for full information about the various commands.",
            "'''",
            "",
        };
    }

    /**
     * Generates python source giving statements which
     * import java classes required for the rest of the python source
     * generated by this class.
     *
     * @return  python source code lines
     */
    private String[] imports() {
        return imports_;
    }

    /**
     * Returns the python name under which a given Java class has been
     * imported into python for use by this class.
     *
     * @param  clazz  java class
     * @return  python name for <code>clazz</code>
     */
    private String getImportName( Class clazz ) {
        String cname = (String) clazzMap_.get( clazz );
        if ( cname == null ) {
            throw new IllegalArgumentException( "Class " + clazz.getName()
                                              + " not imported" );
        }
        return cname;
    }

    /**
     * Generates python source defining utility functions.
     *
     * @return  python source code lines
     */
    private String[] defUtils() {
        return new String[] {
            "class _row_iterator:",
            "    def __init__(self, rowseq):",
            "        self.rowseq = rowseq",
            "    def next(self):",
            "        if self.rowseq.next():",
            "            return self.rowseq.getRow()",
            "        else:",
            "            raise StopIteration",
            "",
            "class _iterable_star_table("
                   + getImportName( WrapperStarTable.class )
                   + "):",
            "    def __init__(self, base):",
            "        " + getImportName( WrapperStarTable.class )
                       + ".__init__(self, base)",
            "    def __iter__(self):",
            "        return _row_iterator(self.getRowSequence())",
            "",
            "class _random_star_table(_iterable_star_table):",
            "    def __init__(self, base):",
            "        _iterable_star_table.__init__(self, base)",
            "    def __len__(self):",
            "        return int(self.getRowCount())",
            "    def __getitem__(self, key):",
            "        return self.getRow(key)",
            "",
            "def _jy_star_table(table):",
            "    if table.isRandom():",
            "        return _random_star_table(table)",
            "    else:",
            "        return _iterable_star_table(table)",
            "",
            "def _map_env_value(pval):",
            "    if pval is None:",
            "        return None",
            "    elif isinstance(pval, " + getImportName( StarTable.class )
                                       + "):",
            "        return pval",
            "    elif _is_container(pval, " + getImportName( StarTable.class )
                                              + "):",
            "        return _to_array(pval, " + getImportName( StarTable.class )
                                              + ")",
            "    else:",
            "        return str(pval)",
            "",
            "def _is_container(value, type):",
            "    valdir = dir(value)",
            "    if '__iter__' in valdir and '__len__' in valdir:",
            "        for item in value:",
            "            if not isinstance(item, type):",
            "                return False",
            "        return True",
            "    else:",
            "        return False",
            "",
            "def _to_array(value, type):",
            "    array = " + getImportName( Array.class )
                           + ".newInstance(type, len(value))",
            "    for i in xrange(len(value)):",
            "        array[i] = value[i]",
            "    return array",
            "",
        };
    }

    /**
     * Generates python source defining the table read function.
     *
     * @param  fname  name of function
     * @return  python source code lines
     */
    private String[] defRead( String fname ) {
        return new String[] {
            "def " + fname + "(location, fmt=None):",
            "    ''' Reads a table from a file or URL.'''",
            "    table = " + getImportName( StarTableFactory.class ) + "()"
                     + ".makeStarTable(location, fmt)",
            "    return _jy_star_table(table)",
        };
    }

    /**
     * Generates python source defining the table write function.
     *
     * @param  fname  name of function
     * @return  python source code lines
     */
    private String[] defWrite( String fname ) {
        return new String[] {
            "def " + fname + "(table, location, fmt=None):",
            "    '''Writes a table to a file.'''",
            "    " + getImportName( StarTableOutput.class ) + "()"
                   + ".writeStarTable(table, location, fmt)",
        };
    }

    /**
     * Generates python source defining the general table filter function.
     *
     * @param  fname  name of function
     * @return  python source code lines
     */
    private String[] defFilter( String fname ) {
        return new String[] {
            "def " + fname + "(table, cmd):",
            "    '''Applies a filter operation to a table "
                 + "and returns the result.'''",
            "    step = " + getImportName( StepFactory.class )
                          + ".getInstance().createStep(cmd)",
            "    return _jy_star_table(step.wrap(table))",
        };
    }

    /**
     * Generates python source defining a specific table filter function.
     *
     * @param  fname  name of function
     * @param  filterNickName  name under which the filter is known in the
     *         filter ObjectFactory
     * @return  python source code lines
     */
    private String[] defCmd( String fname, String filterNickName )
            throws LoadException, SAXException {
        ProcessingFilter filter =
            (ProcessingFilter) StepFactory.getInstance()
                                          .getFilterFactory()
                                          .createObject( filterNickName );
        String usage = filter.getUsage();
        boolean hasUsage = usage != null && usage.trim().length() > 0;
        List lineList = new ArrayList();
        if ( hasUsage ) {
            lineList.add( "def " + fname + "(table, *args):" );
        }
        else {
            lineList.add( "def " + fname + "(table):" );
        }
        lineList.add( "    '''\\" );
        lineList.addAll( Arrays.asList( formatXml( filter
                                                  .getDescription() ) ) );
        lineList.add( "" );
        lineList.add( "The filtered table is returned." );
        if ( hasUsage ) {
            lineList.add( "" );
            lineList.add( "args is a list with words as elements:" );
            lineList.addAll( Arrays
                            .asList( prefixLines( "    ",
                                                  filter.getUsage() ) ) );
        }
        lineList.add( "'''" );
        lineList.add( "    pfilt = " + getImportName( StepFactory.class )
                           + ".getInstance()"
                           + ".getFilterFactory()"
                           + ".createObject(\"" + filterNickName + "\")" );
        lineList.add( "    sargs = [str(a) for a in args]" );
        lineList.add( "    argList = " + getImportName( ArrayList.class )
                                       + "(sargs)" );
        lineList.add( "    step = pfilt.createStep(argList.iterator())" );
        lineList.add( "    return _jy_star_table(step.wrap(table))" );
        return (String[]) lineList.toArray( new String[ 0 ] );
    }

    /**
     * Generates python source defining a function for invoking a STILTS task.
     *
     * @param  fname  name of function
     * @param  taskNickName  name under which the task is known in the task
     *         ObjectFactory
     * @return  python source code lines
     */
    private String[] defTask( String fname, String taskNickName )
            throws LoadException {
        Task task =
            (Task) stilts_.getTaskFactory().createObject( taskNickName );
        List lineList = new ArrayList();
        lineList.add( "def " + fname + "(**kwargs):" );
        lineList.add( "    '''" + task.getPurpose() + ".'''" );
        lineList.add( "    task = " + getImportName( Stilts.class ) + "()"
                                    + ".getTaskFactory()"
                                    + ".createObject('" + taskNickName + "')" );
        lineList.add( "    env = " + getImportName( MapEnvironment.class )
                                   + "()" );
        lineList.add( "    for kw in kwargs.iteritems():" );
        lineList.add( "        env.setValue(kw[0], _map_env_value(kw[1]))" );
        if ( task instanceof ConsumerTask ) {
            lineList.add( "    table = task.createProducer(env).getTable()" );
            lineList.add( "    return _jy_star_table(table)" );
        }
        else {
            lineList.add( "    task.createExecutable(env).execute()" );
            lineList.add( "    return env.getOutputText()" );
        }
        return (String[]) lineList.toArray( new String[ 0 ] );
    }

    /**
     * Formats XML text for output to python source, to be inserted
     * within string literal quotes.
     *
     * @param  xml  xml text
     * @return  python source code lines for string literal content
     */
    private String[] formatXml( String xml ) throws SAXException {

        /* Shorten the lines by csub characters, so they don't overrun when
         * formatted with indentation by python help. */
        int csub = 8;
        String text = formatter_.formatXML( xml, csub );
        List lineList = new ArrayList();
        for ( StringTokenizer toker = new StringTokenizer( text, "\n" );
              toker.hasMoreTokens(); ) {
            String line = toker.nextToken();
            assert "        ".equals( line.substring( 0, csub ) );
            lineList.add( line.substring( csub ) );
        }
        return (String[]) lineList.toArray( new String[ 0 ] );
    }

    /**
     * Add a fixed prefix to each line of an input string.
     *
     * @param  prefix  per-line prefix
     * @param  text  text block, with lines terminated by newline characters
     * @return  python source code lines for string literal content
     */
    private String[] prefixLines( String prefix, String text ) {
        List lineList = new ArrayList();
        for ( StringTokenizer toker = new StringTokenizer( text, "\n" );
              toker.hasMoreTokens(); ) {
            lineList.add( prefix + toker.nextToken() );
        }
        return (String[]) lineList.toArray( new String[ 0 ] );
    }

    /**
     * Outputs an array of lines through a writer.
     *
     * @param  lines  line array
     * @param  writer  destination stream
     */
    private void writeLines( String[] lines, Writer writer )
            throws IOException {
        BufferedWriter bw = new BufferedWriter( writer );
        for ( int i = 0; i < lines.length; i++ ) {
            bw.write( lines[ i ] );
            bw.newLine();
        }
        bw.newLine();
        bw.flush();
    }

    /**
     * Outputs the python source code for the stilts module.
     *
     * @param  writer  destination stream
     */
    public void writeModule( Writer writer )
            throws IOException, LoadException, SAXException {
        writeLines( header(), writer );
        writeLines( imports(), writer );
        writeLines( defUtils(), writer );
        writeLines( defRead( "tread" ), writer );
        writeLines( defWrite( "twrite" ), writer );
        writeLines( defFilter( "tfilter" ), writer );

        /* Write task wrappers. */
        ObjectFactory taskFactory = stilts_.getTaskFactory();
        String[] taskNames = taskFactory.getNickNames();
        for ( int i = 0; i < taskNames.length; i++ ) {
            String name = taskNames[ i ];
            String[] taskLines = defTask( name, name );
            if ( taskLines != null ) {
                writeLines( taskLines, writer );
            }
        }

        /* Write filter wrappers. */
        ObjectFactory filterFactory =
            StepFactory.getInstance().getFilterFactory();
        String[] filterNames = filterFactory.getNickNames();
        for ( int i = 0; i < filterNames.length; i++ ) {
            String name = filterNames[ i ];
            String[] filterLines = defCmd( "tcmd_" + name, name );
            if ( filterLines != null ) {
                writeLines( filterLines, writer );
            }
        }
    }

    /**
     * Writes jython source code for a <code>stilts.py</code> module
     * to standard output.
     * No arguments.
     */
    public static void main( String[] args )
            throws IOException, LoadException, SAXException {
        new JyStilts( new Stilts() )
           .writeModule( new OutputStreamWriter( System.out ) );
    }

    /**
     * Adapter to turn an OutputStream into a Writer.
     * Any attempt to write a non-ASCII character generates an IOException.
     */
    private static class OutputStreamWriter extends Writer {
        private final OutputStream out_;

        /**
         * Constructor.
         *
         * @param  out  destination stream
         */
        OutputStreamWriter( OutputStream out ) {
            out_ = out;
        }

        public void write( char[] cbuf, int off, int len ) throws IOException {
            byte[] buf = new byte[ len ];
            for ( int i = 0; i < len; i++ ) {
                buf[ i ] = toByte( cbuf[ off + i ] );
            }
            out_.write( buf, 0, len );
        }

        public void write( int c ) throws IOException {
            out_.write( toByte( (char) c ) );
        }

        public void flush() throws IOException {
            out_.flush();
        }

        public void close() throws IOException {
            out_.close();
        }

        /**
         * Turns a char into a byte, throwing an exception in case of
         * narrowing issues.
         *
         * @param  c  character
         * @return  equivalent ASCII byte
         */
        private byte toByte( char c ) throws IOException {
            if ( c >= 0 && c <= 127 ) {
                return (byte) c;
            }
            else {
                throw new IOException(
                    "Non-ASCII character 0x" + Integer.toHexString( (int) c ) );
            }
        }
    }
}
