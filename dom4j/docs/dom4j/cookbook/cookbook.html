<html><head><META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>dom4j cookbook</title><link type="text/css" href="cookbook.css" rel="stylesheet"><meta content="DocBook XSL Stylesheets V1.29" name="generator"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div id="NA2E" class="book"><div class="titlepage"><div><h1 class="title"><a name="NA2E"></a>dom4j cookbook</h1></div><div><h3 class="author">Mr.
       Tobias Rademacher</h3><h3 class="author">Mr.
       James Strachan</h3></div><div><p class="pubdate">September 2001</p></div><div><div class="revhistory"><table summary="Revision history" width="100%" border="1"><tr><th colspan="3" valign="top" align="left"><b>Revision History</b></th></tr><tr><td align="left">Revision 0.0.8</td><td align="left">01-09-25</td><td align="left">tradem</td></tr><tr><td colspan="3" align="left">
         <p>Fixed the MSV sample in order make it compilable. Lot's of thanks to Martijn Koster for pointing that out.</p>
      </td></tr><tr><td align="left">Revision 0.0.7</td><td align="left">01-09-03</td><td align="left">tradem</td></tr><tr><td colspan="3" align="left">
      <div class="itemizedlist"><ul><li><p><a name="NA58"></a>Completed the Schema chapter.</p></li><li><p><a name="NA5B"></a>Fixed the XPath sample.</p></li></ul></div>
    </td></tr><tr><td align="left">Revision 0.0.6</td><td align="left">01-08-03</td><td align="left">jstrachan</td></tr><tr><td colspan="3" align="left">
      <div class="itemizedlist"><ul><li><p><a name="NA69"></a>Fixed a few typos and corrected the odd bit of grammar and code.</p></li></ul></div>
    </td></tr><tr><td align="left">Revision 0.0.5</td><td align="left">01-07-09</td><td align="left">tradem</td></tr><tr><td colspan="3" align="left">
      <div class="itemizedlist"><ul><li><p><a name="NA77"></a>Fixing xml structure mistake</p></li><li><p><a name="NA7A"></a>Make Writer samples dom4j 0.6 compliant</p></li></ul></div>
    </td></tr><tr><td align="left">Revision 0.0.4</td><td align="left">01-07-06</td><td align="left">tradem</td></tr><tr><td colspan="3" align="left">
      <div class="itemizedlist"><ul><li><p><a name="NA88"></a>Fixing spelling/gramma mistakes</p></li><li><p><a name="NA8B"></a>Complete vistor listing</p></li></ul></div>
    </td></tr><tr><td align="left">Revision 0.0.3</td><td align="left">01-06-20</td><td align="left">tradem</td></tr><tr><td colspan="3" align="left">
    <p>Completed doc for alpha release</p>
  </td></tr><tr><td align="left">Revision 0.0.2</td><td align="left">01-06-06</td><td align="left">tradem</td></tr><tr><td colspan="3" align="left">
    <p>Added "Secret of DocumentBuilder" and "Serialization"</p>
  </td></tr><tr><td align="left">Revision 0.0.1</td><td align="left">01-06-02</td><td align="left">tradem</td></tr><tr><td colspan="3" align="left">
    <p>Created the document</p>
  </td></tr></table></div></div><div><div class="abstract"><p><a name="NAB5"></a><b>Abstract</b></p><p>This document provides a practical introduction to dom4j. It guides you through by using a lot of examples and is based on dom4j v1.0</p></div></div><hr></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt> <a href="#NAB8">Foreword</a></dt><dt>1. <a href="#NABD">Introducing dom4j</a></dt><dt>2. <a href="#NADD">Creation of an XML Object Model using dom4j</a></dt><dd><dl><dt> <a href="#NAE2">Reading XML data</a></dt><dt> <a href="#NB2C">Integrating with other XML APIs</a></dt><dt> <a href="#NB59">The secret of DocumentFactory</a></dt></dl></dd><dt>3. <a href="#NB9A">Serialization and Output</a></dt><dd><dl><dt> <a href="#NBB0">Serializing to XML</a></dt><dd><dl><dt> <a href="#NBE3">Customizing the output format</a></dt></dl></dd><dt> <a href="#NC15">Printing HTML</a></dt><dt> <a href="#NC2D">Building a DOM tree</a></dt><dt> <a href="#dom4j2SAX">Generating SAX Events</a></dt></dl></dd><dt>4. <a href="#NC67">Navigation in dom4j</a></dt><dd><dl><dt> <a href="#NC7C">Using Iterator</a></dt><dt> <a href="#NC91">Fast index based Navigation</a></dt><dd><dl><dt> <a href="#NCA3">Using a backed List</a></dt><dt> <a href="#NCBA">Using XPath</a></dt><dt> <a href="#NCDB">Using Visitor Pattern</a></dt></dl></dd></dl></dd><dt>5. <a href="#NCF4">Manipulating dom4j</a></dt><dd><dl><dt> <a href="#NCF9">What <tt>org.dom4j.Document</tt> provides</a></dt><dt> <a href="#ND0D">Working with <tt>org.dom4j.Element</tt></a></dt><dt> <a href="#ND1A">Qualified Names</a></dt><dt> <a href="#ND28">Inserting elements</a></dt><dt> <a href="#ND32">Cloning - How many sheeps do you need?</a></dt></dl></dd><dt>6. <a href="#ND5F">Using dom4j with XSLT</a></dt><dt>7. <a href="#ND9D">Schemata-Support</a></dt><dd><dl><dt> <a href="#NDBE">Using XML Schema Data Types in dom4j</a></dt><dt> <a href="#NDCE">Validation</a></dt><dd><dl><dt> <a href="#NDD8">Using Apaches Xerces 1.4.x and dom4j for validation</a></dt><dt> <a href="#NDFB">A perfect team - Multi Schema Validator[MSV] and dom4j </a></dt></dl></dd></dl></dd><dt><a href="#NE1A">Further Reading</a></dt></dl></div><div class="preface" id="NAB8"><div class="titlepage"><div><h2 class="title"><a name="NAB8"></a>Foreword</h2></div></div><p>
</p></div><div class="chapter" id="NABD"><div class="titlepage"><div><h2 class="title"><a name="NABD"></a>Chapter 1. Introducing dom4j</h2></div></div><p>
dom4j is a object model representing an XML Tree in memory.
dom4j offers a easy-to-use API that provides a powerfull set of
features to process, manipulate or navigate XML and work with XPath and XSLT as well as integrate with SAX, JAXP and DOM.
</p><p>
dom4j is designed to be interface-based in order to provide highly configurable implementation strategies.
You are able to create your own XML tree implementations by simply providing a DocumentFactory implementation.
This makes it very simple to resuse much of the dom4j code while extending it to provide whatever implementation features you wish.
</p><p>
This
document will guide you through dom4j's features in a pratical way.
It uses a lot of examples with source code to achive that. The document is
also desinged as a reference so that you don't have to read the entire document right now. This guide concentrates on daily work with
dom4j and is therefore called <i>cookbook</i>.
</p></div><div class="chapter" id="NADD"><div class="titlepage"><div><h2 class="title"><a name="NADD"></a>Chapter 2. Creation of an XML Object Model using dom4j</h2></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt> <a href="#NAE2">Reading XML data</a></dt><dt> <a href="#NB2C">Integrating with other XML APIs</a></dt><dt> <a href="#NB59">The secret of DocumentFactory</a></dt></dl></div><p>
Normally it all starts with a set of xml-files or a single xml file that you want to process, manipulate or navigate through to extract some
values necessary in your application. Most Java Open-Source projects using XML for deployment or as a replacement for property files in order
to get easily readable property data.
</p><div class="section"><a name="NAE2"></a><div class="titlepage"><div><h2 class="title" style="clear: all"><a name="NAE2"></a><span class="title">Reading XML data</span></h2></div></div><p>
How does dom4j help you to get at the data stored in XML?
dom4j comes with a set of
builder classes that parses the xml data and creating
a tree like object structure in memory.
You can easily manipulate and navigate through that model.
The following example shows how you can
read your data using dom4j API.

<pre class="programlisting">
import java.io.File;
import org.dom4j.Document;
import org.dom4j.DocumentException;
import org.dom4j.io.SAXReader;

public class DeployFileLoaderSample {

  /** dom4j object model representation of a xml document. Note: We use the interface(!) not its implementation */
  private Document doc;

  /**
   * Loads a document from a file.
   *
   * @throw a org.dom4j.DocumentException occurs whenever the buildprocess fails.
   */
  public void parseWithSAX(File aFile) throws DocumentException {
    SAXReader xmlReader = new SAXReader();
    this.doc = xmlReader.read(aFile);
  }
}
</pre>

</p><p>
The above example code should clarify the use of <tt>org.dom4j.io.SAXReader</tt> to
build a complete dom4j-tree from a given file.
The org.dom4j.io package of dom4j contains a set of classes
for creating and serializing XML objects.
The read() method
is overloaded so that you able to pass different kind of object that represents a source.
</p><div class="itemizedlist"><ul><li><p><a name="NB08"></a><tt>java.lang.String</tt> - a SystemId is a String that contains a URI e.g. a URL to a XML file</p></li><li><p><a name="NB0D"></a><tt>java.net.URL</tt> - represents a Uniform Ressource Loader or a Uniform Ressource Identifier encasulate in a URL instance</p></li><li><p><a name="NB12"></a><tt>java.io.InputStream</tt> - a open input stream that transports xml data</p></li><li><p><a name="NB17"></a><tt>java.io.Reader</tt> - more compartable puls the abiltiy of setting the encoding scheme</p></li><li><p><a name="NB1C"></a><tt>org.sax.InputSource</tt> - a single input source for a XML entity.</p></li></ul></div><p>
So we decide to add more flexiblity to our <tt>DeployFileLoaderSample</tt> and add new methods.
</p><pre class="programlisting">
import java.io.File;

import org.dom4j.Document;
import org.dom4j.DocumentException;
import org.dom4j.io.SAXReader;

public class DeployFileLoaderSample {

  /** dom4j object model representation of a xml document. Note: We use the interface(!) not its implementation */
  private Document doc;

  /**
   * Loads a document from a file.
   *
   * @param aFile the data source
   * @throw a org.dom4j.DocumentExcepiton occurs whenever the buildprocess fails.
   */
  public void parseWithSAX(File aFile) throws DocumentException {
    SAXReader xmlReader = new SAXReader();
    this.doc = xmlReader.read(aFile);
  }

  /**
   * Loads a document from a file.
   *
   * @param aURL the data source
   * @throw a org.dom4j.DocumentExcepiton occurs whenever the buildprocess fails.
   */
  public void parseWithSAX(URL aURL) throws DocumentException {
    SAXReader xmlReader = new SAXReader();
    this.doc = xmlReader.read(aURL);
  }


}
</pre></div><div class="section"><a name="NB2C"></a><div class="titlepage"><div><h2 class="title" style="clear: all"><a name="NB2C"></a><span class="title">Integrating with other XML APIs</span></h2></div></div><p>
dom4j offers also classes for integration with
the two original XML processing APIs - SAX and DOM.
So far we have been talking about reading a document with SAX.
The <tt>org.dom4j.SAXContentHandler</tt> class implements several
SAX interfaces directly (such as ContentHandler) so that you can embed dom4j
directly inside any SAX application.
You can also use this class to implement your own specific SAX-based Reader class if you need to.
</p><p>
The <tt>DOMReader</tt> class allows you to convert an existing DOM tree
into a dom4j tree.
This could be usefull if you already used DOM and want to replace it step by step
with dom4j or if you just needs some of DOM's
behaviour and want to save memory ressources by transforming it in a dom4j Model.
You are able to transform a DOM Document, a DOM node branch and a single element.
</p><pre class="programlisting">
import org.sax.Document;

import org.dom4j.Document;
import org.dom4j.DocumentException;
import org.dom4j.io.DOMReader;

public class DOMIntegratorSample {

  /** converts a W3C DOM document into a dom4j document */
  public Document buildDocment(org.w3c.dom.Document domDocument) {
    DOMReader xmlReader = new DOMReader();
    return xmlReader.read(domDocument);
  }
}

</pre></div><div class="section"><a name="NB59"></a><div class="titlepage"><div><h2 class="title" style="clear: all"><a name="NB59"></a><span class="title">The secret of DocumentFactory</span></h2></div></div>Right now we have talked a lot of reading exisiting XML information e.g. from files, URL's or even Streams.
Sometimes it's necessary to generate a XML document from scratch within a running Java Application.
The class <tt>org.dom4j.DocumentFactory</tt>defines a set of factory methods to create documents, document
types, elements, attributes, unparsed character data (CDATA), a namespace, an XPathobject, a NodeFilter and
some other useful instances. This makes the <tt>DocumentFactory</tt>class to a central class whenever you have to create
one of these instances by yourself.
</div><pre class="programlisting">

import org.dom4j.DocumentFactory;
import org.dom4j.Document;
import org.dom4j.Element;

public class DeployFileCreator {

  private DocumentFactory factory = DocumentFactory.getInstance();
  private Document doc;

  public void generateDoc(String aRootElement) {
    doc = DocumentFactory.getInstance().createDocument();
    Element root = doc.addElement(aRootElement);
  }

}

</pre><p>
The listing shows how to generate a new Document from scratch.
The method <tt>generateDoc(String aRootElement)</tt> takes a String parameter.
The string value contains the name of the root element of the new document.
As you can see <tt>org.dom4j.DocumentFactory</tt> is a singleton
that is accessable via <tt>getInstance()</tt> as most Java singletons are.
After we obtained the instance we can <tt>DocumentFactory</tt> methods.
They follow the <i>createXXX()</i> naming convention, so if you want to create a Attribute you would
call <i>createAttribute()</i> instead.
If your class uses DocumentFactory a lot or uses a different DocumentFactory instance then
you could add it as a member variable and initiate it via getInstance in your constructor.
</p><pre class="programlisting">

import org.dom4j.DocumentFactory;
import org.dom4j.Document;
import org.dom4j.Element;

public class GranuatedDeployFileCreator {

 private DocumentFactory factory;
 private Document doc;

 public GranuatedDeployFileCreator() {
   this.factory = DocumentFactory.getInstance();
 }

 public void generateDoc(String aRootElement) {
    doc = factory.createDocument();
    Element root = doc.addElement(aRootElement);
 }

}

</pre><p>
The <tt>Document</tt> and <tt>Element</tt>
interfaces have a number of helper methods for creating an XML document programmatically
in a simple way.
</p><pre class="programlisting">

import org.dom4j.Document;
import org.dom4j.DocumentHelper;
import org.dom4j.Element;

public class Foo {

  public Document createDocument() {
    Document document = DocumentHelper.createDocument();
    Element root = document.addElement( "root" );

    Element author2 = root.addElement( "author" )
      .addAttribute( "name", "Toby" )
      .addAttribute( "location", "Germany" )
      .addText( "Tobias Rademacher" );

    Element author1 = root.addElement( "author" )
      .addAttribute( "name", "James" )
      .addAttribute( "location", "UK" )
      .addText( "James Strachan" );

    return document;
  }
}

</pre><p>
As mentioned earlier dom4j is an interface based API.
This means that DocumentFactory and the reader classes in the org.dom4j.io package always use the org.dom4j interfaces
rather than any concrete implementation classes.
The Collection API and W3C's DOM are other examples of APIs that
use this design aproach.
This wide spread design is described by [BillVenners].
</p></div><div class="chapter" id="NB9A"><div class="titlepage"><div><h2 class="title"><a name="NB9A"></a>Chapter 3. Serialization and Output</h2></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt> <a href="#NBB0">Serializing to XML</a></dt><dd><dl><dt> <a href="#NBE3">Customizing the output format</a></dt></dl></dd><dt> <a href="#NC15">Printing HTML</a></dt><dt> <a href="#NC2D">Building a DOM tree</a></dt><dt> <a href="#dom4j2SAX">Generating SAX Events</a></dt></dl></div><p>
Once you have parsed or created a document you want to serialize it to disk or
into a plain (or encrypted) stream. dom4j provides a set of classes to serialize
your dom4j tree in four ways:
</p><div class="itemizedlist"><ul><li><p><a name="NBA4"></a>XML</p></li><li><p><a name="NBA7"></a>HTML</p></li><li><p><a name="NBAA"></a>DOM</p></li><li><p><a name="NBAD"></a>SAX Events</p></li></ul></div><div class="section"><a name="NBB0"></a><div class="titlepage"><div><h2 class="title" style="clear: all"><a name="NBB0"></a><span class="title">Serializing to XML</span></h2></div></div><tt>org.dom4j.io.XMLWriter</tt>is a easy-to-use and easy-to-understand class used
to serialize a dom4jtree to a plain XML.
You are able
to write the XMLtree to either an <tt>java.io.OutputStream</tt>or a <tt>java.io.Writer</tt>.
This can be configured with the overloaded constructor or via the
<tt>setOutputStream()</tt>or <tt>setReader()</tt>methods.
Let's have a look at a example.

<pre class="programlisting">

import java.io.OutputStream;

import org.dom4j.Document;
import org.dom4j.io.XMLWriter;
import org.dom4j.io.OutputFormat;

public class DeployFileCreator {

 private Document doc;

 public void serializetoXML(OutputStream out, String aEncodingScheme) throws Exception {
   OutputFormat outformat = OutputFormat.createPrettyPrint();
   outformat.setEncoding(aEncodingScheme);
   XMLWriter writer = new XMLWriter(out, outformat);
   writer.write(this.doc);
   writer.flush();
 }

}
</pre><p>
We use the constructor of <tt>XMLWriter</tt> to pass a to given
<tt>OutputStream</tt> along with the required character encoding.
It is easier to use a <tt>Writer</tt> rather than an <tt>OutputStream</tt>,
because the <tt>Writer</tt>  is String based and so has ness
character encoding issues.
The write() methods of <tt>Writer</tt> are overloaded so that you can write all of the dom4j objects individually if required.
</p><div class="section"><a name="NBE3"></a><div class="titlepage"><div><h3 class="title"><a name="NBE3"></a><span class="title">Customizing the output format</span></h3></div></div><p>
The default output format is to write the XML document as-is.
If you want to change the output format then there is a class
<tt>org.dom4j.io.OutputFormat</tt> which allows you to define pretty printing options,
to suppress the output of the XML declaration, change the line ending and so on.
There is also a helper method <tt>OutputFormat.createPrettyPrint()</tt> which will
create a default pretty printing format that you can further customize if you wish.
</p><pre class="programlisting">

import java.io.OutputStream;

import org.dom4j.Document;
import org.dom4j.io.XMLWriter;
import org.dom4j.io.OutputFormat;

public class DeployFileCreator {

 private Document doc;

  public void serializetoXML(OutputStream out, String aEncodingScheme) throws Exception {
   OutputFormat outformat = OutputFormat.createPrettyPrint();
   outformat.setEncoding(aEncodingScheme);
   XMLWriter writer = new XMLWriter(out, outformat);
   writer.write(this.doc);
   writer.flush();
 }


}
</pre><p>
An interesting feature of <tt>OutputFormat</tt> the ability to set
the character encoding. It is a good idiom to use this mechansim for setting the encoding
as the XMLWriter will be able to use this encoding to create an OutputStream as well
as to output the XML declaration.
</p><p>
The <tt>close()</tt> method closes the underlying <tt>Writer</tt>.
</p><pre class="programlisting">

import java.io.OutputStream;

import org.dom4j.Document;
import org.dom4j.io.XMLWriter;
import org.dom4j.io.OutputFormat;

public class DeployFileCreator {

 private Document doc;
 private OutputFormat outFormat;

 public DeployFileCreator() {
   this.outFormat = OuputFormat.getPrettyPrinting();
 }

 public DeployFileCreator(OutputFormat outFormat) {
   this.outFormat = outFormat;
 }

 public void writeAsXML(OutputStream out) throws Exception {
   XMLWriter writer = new XMLWriter(outFormat, this.outFormat);
   writer.write(this.doc);
 }

 public void writeAsXML(OutputStream out, String encoding) throws Exception {
   this.outFormat.setEncoding(encoding);
   this.writeAsXML(out);
 }

}
</pre><p>
The serialization methods in our little example will now set encoding using <tt>OutputFormater</tt>.
The default encoding if none is specifed will be UTF-8.
If you need a simple output on screen for debbuing or testing you can omit setting of
a <tt>Writer</tt> or an <tt>OutputStream</tt> completely
as <tt>XMLWriter</tt> will default to <tt>System.out</tt>.
</p></div></div><div class="section"><a name="NC15"></a><div class="titlepage"><div><h2 class="title" style="clear: all"><a name="NC15"></a><span class="title">Printing HTML</span></h2></div></div><p>
<tt>HTMLWriter</tt> takes a dom4j tree
and formats it to a stream as HTML. This formatter is similar to
<tt>XMLWriter</tt> but outputs the text of CDATA and Entity sections rather than the serialised
format as in XML and also supports many HTML element which have no corresponding close tag
such as for &lt;BR&gt; and &lt;P&gt;
</p><pre class="programlisting">

import java.io.OutputStream;

import org.dom4j.Document;
import org.dom4j.io.HTMLWriter;
import org.dom4j.io.OutputFormat;

public class DeployFileCreator {

 private Document doc;
 private OutputFormat outFormat;

 public DeployFileCreator() {
   this.outFormat = OuputFormat.getPrettyPrinting();
 }

 public DeployFileCreator(OutputFormat outFormat) {
   this.outFormat = outFormat;
 }

 public void writeAsHTML(OutputStream out) throws Exception {
   HTMLWriter writer = new HTMLWriter(outFormat, this.outFormat);
   writer.write(this.doc);
   writer.flush();
 }

}
</pre></div><div class="section"><a name="NC2D"></a><div class="titlepage"><div><h2 class="title" style="clear: all"><a name="NC2D"></a><span class="title">Building a DOM tree</span></h2></div></div><p>
Sometimes it's necessary to transform your dom4j tree
into a DOM tree, because you are currently refactoring your application.
dom4j is very convient for integration with older XML
API's like DOM or SAX
(see <a name="dom4j2SAX"></a>). Let's move to an example:
</p><pre class="programlisting">
import org.w3c.dom.Document;

import org.dom4j.Document;
import org.dom4j.io.DOMWriter;

public class DeployFileLoaderSample {

  private org.dom4j.Document doc;

  public org.w3c.dom.Document transformtoDOM() {
    DOMWriter writer = new DOMWriter();
    return writer.write(this.doc);
  }
}

</pre></div><div class="section"><a name="dom4j2SAX"></a><div class="titlepage"><div><h2 class="title" style="clear: all"><a name="dom4j2SAX"></a><span class="title">Generating SAX Events</span></h2></div></div><p>
If you want to output a document as sax events in order to integrate with some existing SAX
code, you can use the <tt>org.dom4j.SAXWriter</tt> clas.
</p><pre class="programlisting">
import org.xml.ConentHandler;

import org.dom4j.Document;
import org.dom4j.io.SAXWriter;

public class DeployFileLoaderSample {

  private org.dom4j.Document doc;

  public void transformtoSAX(ContentHandler ctxHandler) {
     SAXWriter writer = new SAXWriter();
     writer.setContentHandler(ctxHandler);
     writer.write(doc);
  }
}

</pre><p>
Using <tt>SAXWriter</tt> is fairly easy as you can see.
You can resolve also <tt>org.dom.Element</tt> which means that
you are able to process a single element branch or even a single node with SAX.
</p></div></div><div class="chapter" id="NC67"><div class="titlepage"><div><h2 class="title"><a name="NC67"></a>Chapter 4. Navigation in dom4j</h2></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt> <a href="#NC7C">Using Iterator</a></dt><dt> <a href="#NC91">Fast index based Navigation</a></dt><dd><dl><dt> <a href="#NCA3">Using a backed List</a></dt><dt> <a href="#NCBA">Using XPath</a></dt><dt> <a href="#NCDB">Using Visitor Pattern</a></dt></dl></dd></dl></div><p>
dom4j offers several powerful mechansims for navigating through a document:-
</p><div class="itemizedlist"><ul><li><p><a name="NC6D"></a>Using Iterators</p></li><li><p><a name="NC70"></a>Fast index based navigation</p></li><li><p><a name="NC73"></a>Using a backed List</p></li><li><p><a name="NC76"></a>Using XPath</p></li><li><p><a name="NC79"></a>In-Build GOF Visitor Pattern</p></li></ul></div><div class="section"><a name="NC7C"></a><div class="titlepage"><div><h2 class="title" style="clear: all"><a name="NC7C"></a><span class="title">Using Iterator</span></h2></div></div><p>
Most Java developers have already used java.util.Iterator or it's ancestor
<tt>java.util.Enumeration</tt>.
Both classe are fairly involed into the Collection API and used
to visit the elements of a collection. The Iterator is appylied usually with a while
loop and Iterator methods hasNext() and next() item. Right now Collection API
dont support Generic Type (like C++ Templates), but there's already a Early Access Implemention available.
Now let's move to an living example of it in dom4j.
</p></div><pre class="programlisting">

import java.util.Iterator;

import org.dom4j.Document;
import org.dom4j.Element;

public class DeployFileLoaderSample {

  private org.dom4j.Document doc;
  private org.dom4j.Element root;

  public void iterateRootChildren() {
    root = this.doc.getRootElement();
    Iterator elementIterator = root.elementIterator();
    while(elementIterator.hasNext()){
      Element elmeent = (Element)elementIterator.next();
      System.out.println(element.getName());
    }
  }
}
</pre><p>
The above example might be a little bit confusing if you are not too familiar with the Collections API.
Casting is necessary when you want to acess the object. Java Generics will solve this problem in future.
</p><pre class="programlisting">
import java.util.Iterator;

import org.dom4j.Document;
import org.dom4j.Element;

public class DeployFileLoaderSample {

  private org.dom4j.Document doc;
  private org.dom4j.Element root;

  public void iterateRootChildren(String aFilterElementName) {
    root = this.doc.getRootElement();
    Iterator elementIterator = root.elementIterator(aFilterElementName);
    while(elementIterator.hasNext()){
      Element elmeent = (Element)elementIterator.next();
      System.out.println(element.getName());
    }
  }
}
</pre><p>
Now the the method iterates on such Elements that have the <i>same name</i> as the parameterized String only. This can be used as a kind of
filter applied on top of Collection API's Iterator.
</p><div class="section"><a name="NC91"></a><div class="titlepage"><div><h2 class="title" style="clear: all"><a name="NC91"></a><span class="title">Fast index based Navigation</span></h2></div></div><p>
Sometimes if you need to walk a large tree very quickly, creating an <tt>java.io.Iterator</tt>
instance to loop through each <tt>Element</tt>'s children can be expensive in
high performance environment.
To help this situation, dom4j provides a fast index based looping as follows.
</p><pre class="programlisting">
  public void treeWalk(Document document) {
    treeWalk( document.getRootElement() );
  }

  public void treeWalk(Element element) {
    for ( int i = 0, size = element.nodeCount(); i &lt; size; i++ ) {
      Node node = element.node(i);
      if ( node instanceof Element ) {
        treeWalk( (Element) node );
      }
      else {
        // do something....
      }
    }
  }
</pre><div class="section"><a name="NCA3"></a><div class="titlepage"><div><h3 class="title"><a name="NCA3"></a><span class="title">Using a backed List</span></h3></div></div><p>
You can navigate through an <tt>Element</tt>'s children
using a backed <tt>List</tt> such that modifications to the
<tt>List</tt> are reflected back into the <tt>Element</tt>.
It also means that all of the methods on <tt>List</tt> can be used.
</p><pre class="programlisting">
import java.util.List;

import org.dom4j.Document;
import org.dom4j.Element;

public class DeployFileLoaderSample {

  private org.dom4j.Document doc;

  public void iterateRootChildren() {
    Element root = doc.getRootElement();

    List elements = root.elements;

    // we have access to the size() and other List methods
    if ( elements.size() &gt; 4 ) {
      // now lets remove a range of elements
      elements.subList( 3, 4 ).clear();
    }
  }
}
</pre></div><div class="section"><a name="NCBA"></a><div class="titlepage"><div><h3 class="title"><a name="NCBA"></a><span class="title">Using XPath</span></h3></div></div><p>
XPath is is one of the most usefull features of dom4j.
You can use it to retrieve nodes from any location as well as evaluating complex expressions.
A good XPath refercence can be found in Micheal Kay's XSLT book [XSLTReference]
along with the [Zvon] Zvon tutorial.
</p></div><pre class="programlisting">
import java.util.Iterator;

import org.dom4j.Documet;
import org.dom4j.DocumentHelper;
import org.dom4j.Element;
import org.dom4j.XPath;

public class DeployFileLoaderSample {

  private org.dom4j.Document doc;
  private org.dom4j.Element root;

  public void browseRootChildren() {
    XPath xpathSelector = DocumentHelper.createXPath("/people/person[@name='James']");
    List results = xpathSelector.selectNodes(doc);
    for ( Iterator iter = result.iterator(); iter.hasNext(); ) {
      Element element = (Element) iter.next();
      System.out.println(element.getName();
    }


  }

}
</pre><p>
As selectNodes returns a List we can apply <tt>Iterator</tt>
or any other operation avaliable on <tt>java.util.List</tt>.

</p><div class="section"><a name="NCDB"></a><div class="titlepage"><div><h3 class="title"><a name="NCDB"></a><span class="title">Using Visitor Pattern</span></h3></div></div><p>
The visitor pattern has a recrusive behavior and acts like SAX
in the way that partical traversal is <i>not</i> possible.
This means the complete document or the complete element branch will be visited.
 You should consider wisely when you want to use Visitor pattern, but then it
offers a powerful and elegant way of navigation.
This document doesn't explain Vistor Pattern in deepth,
[GoF98] covers more information.
</p><pre class="programlisting">
import java.util.Iterator;

import org.dom4j.Visitor;
import org.dom4j.VisitorSupport;
import org.dom4j.Document;
import org.dom4j.Element;

public class VisitorSample {

  public void demo(Document doc) {

    Visitor visitor = new VisitorSupport() {
      public void visit(Element element) {
        System.out.println(
          "Entity name: " + element.getName()  + "text " + element.getText();
        );
      }
    };

    doc.accept( visitor );
  }
}

</pre><p>
As you can see we used a anonymous inner class to override the
<tt>VisitorSupport</tt> callback adapter method
visit(Element element) and the accept() method starts
the vistor mechansim.
Please keep in mind that the <i>complete</i> element branch is visited.
</p></div></div></div><div class="chapter" id="NCF4"><div class="titlepage"><div><h2 class="title"><a name="NCF4"></a>Chapter 5. Manipulating dom4j</h2></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt> <a href="#NCF9">What <tt>org.dom4j.Document</tt> provides</a></dt><dt> <a href="#ND0D">Working with <tt>org.dom4j.Element</tt></a></dt><dt> <a href="#ND1A">Qualified Names</a></dt><dt> <a href="#ND28">Inserting elements</a></dt><dt> <a href="#ND32">Cloning - How many sheeps do you need?</a></dt></dl></div><p>
Accessing XML content statically alone would not very special. Thus dom4j offers several methods for manipulation a documents content.
</p><div class="section"><a name="NCF9"></a><div class="titlepage"><div><h2 class="title" style="clear: all"><a name="NCF9"></a><span class="title">What <tt>org.dom4j.Document</tt> provides</span></h2></div></div><p>
A <tt>org.dom4j.Document</tt> allows you to configure and retreive the root element.
You are also able to set the DOCTYPE or a SAX based <tt>EntityResolver</tt>.
An empty <tt>Document</tt> should be created via <tt>org.dom4j.DocumentFactory</tt>.
</p></div><div class="section"><a name="ND0D"></a><div class="titlepage"><div><h2 class="title" style="clear: all"><a name="ND0D"></a><span class="title">Working with <tt>org.dom4j.Element</tt></span></h2></div></div><p>
<tt>org.dom4j.Element</tt> is a powerfull interface providing lots of methods for manipulation an Element.
</p><pre class="programlisting">

  public void changeElementName(String aName) {
    this.element.setName(aName);
  }

  public void changeElementText(String aText) {
    this.element.setText(aText);
  }

</pre></div><div class="section"><a name="ND1A"></a><div class="titlepage"><div><h2 class="title" style="clear: all"><a name="ND1A"></a><span class="title">Qualified Names</span></h2></div></div><p>
  An XML Element should have a qualified name. A qualified name consits normally of a Namespace and a
  local name. It's recommend to use <tt>org.dom4j.DocumentFactory</tt> to create Qualifed
  Names that are provided by <tt>org.dom4j.QName</tt> instances.
  </p><pre class="programlisting">

  import org.dom4j.Element;
  import org.dom4j.Document;
  import org.dom4j.DocumentFactory;
  import org.dom4j.QName;

  public class DeployFileCreator {

   protected Document deployDoc;
   protected Element root;

   public void DeployFileCreator()
   {
     QName rootName = DocumentFactory.getInstance().createQName("preferences", "", "http://java.sun.com/dtd/preferences.dtd");
     this.root = DocumentFactory.getInstance().createElement(rootName);
     this.deployDoc = DocumentFactory.getInstance().createDocument(this.root);
   }
  }

  </pre></div><div class="section"><a name="ND28"></a><div class="titlepage"><div><h2 class="title" style="clear: all"><a name="ND28"></a><span class="title">Inserting elements</span></h2></div></div><p>
  Somethimes it's necessary to insert an element somewhere in a existing XML Tree. As dom4j is based on Collection API this
  causes no problems. The following expample shows how it could be done.
  </p><pre class="programlisting">

    public void insertElementAt(Element newElement, int index) {
      Element parent = this.element.getParent();
      List list = parent.content();
      list.add(index, newElement);
    }

    public void testInsertElementAt() {

    //insert an clone of current element after the current element
      Element newElement = this.element.clone();
      this.insertElementAt(newElement, this.root.indexOf(this.element)+1);

    // insert an clone of current element before the current element
      this.insertElementAt(newElement, this.root.indexOf(this.element));
    }
  </pre><p>
  Studying the Collection API should lead to more solutions for similar problem and you will notify that dom4j fits well in the Collection Framework and both complement
  each other in order to processing xml document in a comfortable way.
  </p></div><div class="section"><a name="ND32"></a><div class="titlepage"><div><h2 class="title" style="clear: all"><a name="ND32"></a><span class="title">Cloning - How many sheeps do you need?</span></h2></div></div><p>
  Elements can be cloned as well. Usually cloning is supported in Java with clone() method that is derived from <tt>Object</tt>, but a cloneable Object have to
  implement interface <tt>Clonable</tt>. Java support shallow copying by simply returning <i>this</i> for standard. dom4j supporting  deep cloning
  because shallow copies would not make sence in context of an XML object model. This means that cloning can take a while because the complete tree branch or event the document
  will be cloned. Now we have a short look <i>how</i> dom4j cloning mechanism is used.
  </p><pre class="programlisting">

  import org.dom4j.Document;
  import org.dom4j.Element;

  public class DeployFileCreator {


   private Element cloneElement(String name) {
    return this.root.element(name).clone();
   }

   private Element cloneDetachElement(String name) {
     return this.root.createCopy(name);
   }

   public class TestElement extends junit.framework.TestCase {

     public void testCloning() throws junit.framwork.AssertionFailedException {
       assert("Test cloning with clone() failed!", this.creator.cloneElement("Key") != null);
       assert("Test cloning with createCopy() failed!", this.creator.cloneDetachElement() != null);
     }
   }
  }
  </pre><p>
  The difference between <i>createCopy(...)</i> and <i>clone()</i> is that first is a polymorphic method that created a decoupled deep copy whereas <i>clone()</i> returns a returns a deep copy of the
  current document or element itself.
  </p><div class="caution" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a name="ND51">Consider use of Cloning</a></h3><p>
   Cloning might be usefull when you want to build a element pool. Such a pool should be desinged carefully keeping
   <tt>OutOfMemoryException</tt> in mind. You could alternativly consider to use Reference API [Pawlan98]
    or Dave Millers approach [JavaWorldTip76].
  </p></div></div></div><div class="chapter" id="ND5F"><div class="titlepage"><div><h2 class="title"><a name="ND5F"></a>Chapter 6. Using dom4j with XSLT</h2></div></div><p>
With eXtensible Stylesheet Language XML got's a powerfull method of transforming itself into other formats. Developing  Exportfilter's for dataformats are normally a hard job and so for XML XSL simpliefs that work. The aronym XSLT means the process of transformation, that is usally done by an XSL compliant Processor. XSL covers following subjects:
</p><div class="itemizedlist"><ul><li><p><a name="ND65"></a>XSL Style Sheet</p></li><li><p><a name="ND68"></a>XSL Processor for XSLT</p></li><li><p><a name="ND6B"></a>FOP Processor for FOP</p></li><li><p><a name="ND6E"></a>An XML source</p></li></ul></div><p>
Since JaXP 1.1 TraX is the common API for proceeding a XSL Stylesheet inside of Java. You start with a <tt>TransformerFactory</tt> and dealing with <tt>Result</tt> and <tt>Source</tt>. A <tt>Source</tt> contains the source xml file that should be transformed. <tt>Result</tt>'s contains the the result of transformation. dom4j offers <tt>org.dom4j.io.DocumentResult</tt> and <tt>org.dom4j.io.DocumenSource</tt> for compatiblity to TrAX.
Whereas <tt>org.dom4j.io.DocumentResult</tt> contains a <tt>org.dom4j.Document</tt> as result tree, <tt>DocumentSource</tt> takes dom4j <tt>Document</tt>s and pepare them for transformation. Both classes are build on top of TraX own SAX classes. This is much more perfomant as a DOM adaptation. The following example explains the use of XSLT with TraX and dom4j.
</p><pre class="programlisting">
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.stream.StreamSource;

import org.dom4j.Document;
import org.dom4j.io.DocumentResult;
import org.dom4j.io.DocumentSource;

public class DocumentStyler
{
    private Transformer transformer;

    public DocumentStyler(Source aStyleSheet) throws Exception {
        // create the transformer
        TransformerFactory factory = TransformerFactory.newInstance();
        transformer = factory.newTransformer( aStyleSheet );
    }

    public Document transform(Document aDocument, Source aStyleSheet) throws Exception {

        // perform the transformation
        DocumentSource source = new DocumentSource( aDocument );
        DocumentResult result = new DocumentResult();
        transformer.transform(source, result);

        // return the resulting document
        return result.getDocument();
    }
}

</pre><p>
Imagine that you use XSLT to process a XML Schema in order to generate a empty template xml file accoring the schema contraints. The above sample should how easy the Java code is when you use dom4j and it's TraX support. If you use TemplateGenerator a lot you should consider the application of singleton pattern, but for this example I avoided this for simplicity. More information about TraX is provided  <a href="http://www.java.sun.com/xml" target="_top">here</a>.
</p></div><div class="chapter" id="ND9D"><div class="titlepage"><div><h2 class="title"><a name="ND9D"></a>Chapter 7. Schemata-Support</h2></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt> <a href="#NDBE">Using XML Schema Data Types in dom4j</a></dt><dt> <a href="#NDCE">Validation</a></dt><dd><dl><dt> <a href="#NDD8">Using Apaches Xerces 1.4.x and dom4j for validation</a></dt><dt> <a href="#NDFB">A perfect team - Multi Schema Validator[MSV] and dom4j </a></dt></dl></dd></dl></div><p>
The first way to describe and constrain the form and data of a XML document is as old as XML itself.
Document Type Definitions are used since the XML Specicifiation has been published.
At lot of applications used this DTDs to describe and validate her documents. Unfortunatly
the DTD Syntax was not that powerfull as needed. Written in SGML, DTDs are also not so easy to handle as
XML is.
</p><p>
During the time of DTDs a couple of people invents several other possible ways that could
be used to describe a document and force its content in the desired form. Latly the
W3C published XML Schema Specification with a couple of massive inprovements. XML Schemas
are no described by XML and the way to describe a Schema is done with DTD once and not longer
by every XML user. A growing group of people using XML Schema now. But XML Schema isn't perfect.
So a few people swear by Relax or Relax NG. The reader of this document is able to choose one of
the following technologies:
</p><div class="itemizedlist"><ul><li><p><a name="NDA5"></a>Relax NG (Regular Language description for XML Next Generation)[RelaxNG]</p></li><li><p><a name="NDAA"></a>Relax (Regular Language description for XML)[Relax]</p></li><li><p><a name="NDAF"></a>TREX[TREX]</p></li><li><p><a name="NDB4"></a>XML DTDs[DTD]</p></li><li><p><a name="NDB9"></a>XML Schema[XSD]</p></li></ul></div><div class="section"><a name="NDBE"></a><div class="titlepage"><div><h2 class="title" style="clear: all"><a name="NDBE"></a><span class="title">Using XML Schema Data Types in dom4j</span></h2></div></div><p>
dom4j supports currently XML Schema Data Types[DataTypes] only.
The dom4j implementation is based on top of MSV. Earlier dom4j releases are built
on top of Suns Tranquilo (xsdlib.jar) but we use MSV now, because its uses
offers the same Tranquilo plus exiting additional features we discuss later.
</p><pre class="programlisting">
import java.util.List;

import org.dom4j.Document;
import org.dom4j.DocumentHelper;
import org.dom4j.XPath;
import org.dom4j.io.SAXReader;
import org.dom4j.dataType.DataTypeElement;

public class SchemaTypeDemo {

public static void main(String[] args) {

  SAXReader reader = new SAXReader();
  reader.setDocumentFactory( DatatypeDocumentFactory.getInstance() );
  Document schema =  return reader.read(xmlFile)
  XPath xpathSelector = DocumentHelper.createXPath("xsd:schema/xsd:complexType[@name='Address']/xsd:structure/xsd:element[@type]");
  List xsdElements = xpathSelector.selectNodes(schema);

  for (int i=0; i &lt; xsdElements.size(); i++) {
    DataElement tempXsdElement = (DatatypeElement)xsdElements.get(i);

    if (tempXsdElement.getData() instanceof Integer) {
       tempXsdElement.setData(new Integer(23));
     }
  }
}
</pre><div class="caution" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a name="NDC9">Alpha status</a></h3><p>
Note that the Data Type support is still alpha. If you find any bug, please report it to
the mailing listy. This helps us to make the Data Type support more error-prone and trustworthy.
</p></div></div><div class="section"><a name="NDCE"></a><div class="titlepage"><div><h2 class="title" style="clear: all"><a name="NDCE"></a><span class="title">Validation</span></h2></div></div><p>
dom4j currently comes not with its one validation engine. You are forced to use a different
engine instead. We recommend the use of Xerces 1.4.x or later in the past, but now you are
able to use Suns Multi Schema Validator as well. Xerces is able to validate against DTDs and
XML Schema, but not against TREX or Relax. You would belive it, but the Mulit Schema Validator Libery
supports all earlier mentioned types for validation.
</p><div class="caution" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a name="NDD3">Consider use of Validation</a></h3><p>
Using Valdiation consumes valueable resources. Use it wisely.
</p></div><div class="section"><a name="NDD8"></a><div class="titlepage"><div><h3 class="title"><a name="NDD8"></a><span class="title">Using Apaches Xerces 1.4.x and dom4j for validation</span></h3></div></div><p>
Using Xerecs 1.4.x for Schema and Validation is very easy. You have to download
Xerces at Apaches XML web sites. The past has shown that not always the newest version
is best. You can view there mailing lists in order to find out which version is buggy
and which works well. For Schema support at least Xerecs 1.4.0 is necessary. If you
work according the following rules valdation should be no problem.
</p><div class="itemizedlist"><ul><li><p><a name="NDDE"></a>Turn on validation mode - which is false for default - using a SAXReader instance</p></li><li><p><a name="NDE1"></a>Set the following Xerces property http://apache.org/xml/properties/schema/external-noNamespaceSchemaLocation using the schema URI.</p></li><li><p><a name="NDE4"></a>Create a SAX XMLErrorHandler and install it to your SAXReader instance.</p></li><li><p><a name="NDE7"></a>Parse and validate the Document.</p></li><li><p><a name="NDEA"></a>Output Validation/Parse Errors errors.</p></li></ul></div><pre class="programlisting">
import org.dom4j.Document;
import org.dom4j.Element;
import org.dom4j.io.OutputFormat;
import org.dom4j.io.SAXReader;
import org.dom4j.io.XMLWriter;
import org.dom4j.util.XMLErrorHandler;


import org.xml.sax.ErrorHandler;
import org.xml.sax.SAXParseException

public class SimpleValidationDemo {

public static void main(String[] args) {
  SAXReader reader = new SAXReader();

  reader.setValidation(true);

  // specify the schema to use
  reader.setProperty(
   "http://apache.org/xml/properties/schema/external-noNamespaceSchemaLocation",
   "prices.xsd"
  );

  // add an error handler which turns any errors into XML
   XMLErrorHandler errorHandler = new XMLErrorHandler();
   reader.setErrorHandler( errorHandler );

  // now lets parse the document
  Document document = reader.read(args[0]);

 // now lets output the errors as XML
  XMLWriter writer = new XMLWriter( OutputFormat.createPrettyPrint() );
  writer.write( errorHandler.getErrors() );
}

</pre><div class="caution" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a name="NDF0">Xerces and Crimson</a></h3><p>
Both, Xerecs and Crimson, are JaXPable Parsers. You should be carefully in using
Crimson and Xerces in same classpath. Xerces will work only correct when it is the
mentioned <i>before</i> Crimson in classpath. At this time I
recommend that you should either Xereces <i>or</i> Crimson.
</p></div></div><div class="section"><a name="NDFB"></a><div class="titlepage"><div><h3 class="title"><a name="NDFB"></a><span class="title">A perfect team - Multi Schema Validator[MSV] and dom4j </span></h3></div></div><p>
Kohsuke Kawaguchi a deleloper from Sun created a extremly usefull tool for validtion of XML
documents. The Multi Schema Validator (MSV) supports following kinds of Schmemata:
</p><div class="itemizedlist"><ul><li><p><a name="NE04"></a>Relax NG</p></li><li><p><a name="NE07"></a>Relax </p></li><li><p><a name="NE0A"></a>TREX</p></li><li><p><a name="NE0D"></a>XML DTDs</p></li><li><p><a name="NE10"></a>XML Schema</p></li></ul></div><p>
You are able to use the MSV and dom4j in order to validate your Documents. The following examples shows you how to use
the MSV and with dom4j.
</p><pre class="programlisting">
import com.sun.msv.grammar.Grammar;
import com.sun.msv.reader.util.GrammarLoader;
import com.sun.msv.reader.util.IgnoreController;
import com.sun.msv.verifier.DocumentDeclaration;
import com.sun.msv.verifier.ValidityViolation;
import com.sun.msv.verifier.Verifier;
import com.sun.msv.verifier.VerificationErrorHandler;

import javax.xml.parsers.SAXParserFactory;

import org.dom4j.Document;
import org.dom4j.DocumentException;
import org.dom4j.io.SAXReader;
import org.dom4j.io.SAXWriter;

import org.xml.sax.ContentHandler;
import org.xml.sax.ErrorHandler;
import org.xml.sax.Locator;
import org.xml.sax.SAXParseException;

import java.net.URL;
import java.io.File;

public class Schema {

    public static void main(String argv[]) {
        try {
            String filename = argv[0];
            String schema = argv[1];

            URL fileURL = new File(filename).toURL();
            URL schemaURL = new File(schema).toURL();

            SAXReader reader = new SAXReader();
            Document doc = reader.read(fileURL);
            validate(doc, schemaURL.toExternalForm());
        } catch (Exception e) {
            e.printStackTrace(System.err);
        }
    }

    static public void validate(Document doc, String schema)
        throws Exception {

        // Turn on Namespace handling in theJAXP SAXParserFactory
        SAXParserFactory saxFactory = SAXParserFactory.newInstance();
        saxFactory.setNamespaceAware(true);

        // create MSVs DocumentDeclaration by overriding
        // a IgnoreController in an anonyous inner class
        DocumentDeclaration docDeclaration =
            GrammarLoader.loadVGM(schema, new IgnoreController() {

                    public void error(Locator[] locations,
                                      String message,
                                      Exception exception) {
                        System.out.println("ERROR: " + message);
            }

            public void error(Locator[] locations, String message) {
                System.out.println("WARNING: " + message);
            }
        }, saxFactory);

        // create a new Verifier that reports vlidation errors
        // using an anonymous inner class
        Verifier verifier =
            new Verifier(docDeclaration, new VerificationErrorHandler() {

                    public void onError(ValidityViolation e) {
                        System.out.println("Document invalid! Error: " + e);
                    }

                    public void onWarning(ValidityViolation e) {
                        System.out.println("Document invalid! Warning: " + e);
                    }
                });

        SAXWriter writer = new SAXWriter((ContentHandler) verifier);
        writer.setErrorHandler(new ErrorHandler() {

                public void error(SAXParseException e) {
                    System.out.println("ERROR:" + e);
                }

                public void fatalError(SAXParseException e) {
                    System.out.println("Fatal:" + e);
                }

                public void warning(SAXParseException e) {
                    System.out.println("Warning:" + e);
                }
        });

        // validate now!
        writer.write(doc);
        if (verifier.isValid())
            System.err.println("The document was valid");
        else
            System.err.println("The document was not valid");
    }
}
</pre><p>
At the first look the use of MSV looks not trival. The Xerces validation is
easier to use in code, but not so powerfull. Currently its not clear if XML Schema
will be the next standard for validation. Relax NG gots a even more growing
lobby. If you want to build a open application that is not fixed to a
specific XML parser and specific XML Schematas you should use this powerfull
tool.
</p></div></div></div><div class="bibliography"><h2 class="title"><a name="NE1A">Further Reading</a></h2><div class="bibliodiv"><h3 class="title"><a name="NE1D">Books</a></h3><div class="biblioentry" id="NE20"><a name="NE20"></a><p><span class="abbrev">[XSLTReference] </span><span class="authorgroup">Michael Kay. </span><span class="copyright">Copyright &copy; 2001 Worx Press, Inc.. </span><span class="isbn">1-861-005067. </span><span class="publisher"><span class="publishername">Worx Press. </span></span><span class="title"><I>XSLT Programmer's Reference 2'nd Edition</I>. </span><span class="seriesinfo"><span class="title"><I>Programmer To Programmer</I>. </span><span class="publisher"><span class="publishername">Worx Press. </span></span></span></p></div><div class="biblioentry" id="NE3B"><a name="NE3B"></a><p><span class="abbrev">[GoF95] </span><span class="authorgroup">Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides. </span><span class="copyright">Copyright &copy; 1995 Addison Wesley Pub, Co.. </span><span class="isbn">0-201-633-612. </span><span class="publisher"><span class="publishername">Addison-Wesley. </span></span><span class="title"><I>Design Patterns: Elements of Reusable Object-Orientated Software</I>. </span></p></div></div></div><div class="bibliodiv"><h3 class="title"><a name="NE5F">Articles</a></h3><div class="biblioentry" id="NE62"><a name="NE62"></a><p><span class="abbrev">[Pawlan98] </span><span class="authorgroup">Monica Pawlan. </span><span class="copyright">Copyright &copy; 1998 http://developer.java.sun.com/javatips/jw-tips76.html. </span><span class="title"><I>Reference Objects and Garbage Collection</I>. </span></p></div><div class="biblioentry" id="NE72"><a name="NE72"></a><p><span class="abbrev">[JavaTip76] </span><span class="authorgroup">Dave Miller. </span><span class="copyright">Copyright &copy;  http://www.javaworld.com/javaworld/javatips/jw-javatip76.html. </span><span class="title"><I>An alternative to the deep copying technique</I>. </span></p></div><div class="biblioentry" id="NE80"><a name="NE80"></a><p><span class="abbrev">[BillVenners] </span><span class="authorgroup">Bill Venners. </span><span class="copyright">Copyright &copy;  http://www.artima.com/designtechniques/interfaces.html. </span><span class="title"><I>Designing with Interfaces - One Programmer's Struggle to Understand the Interface</I>. </span></p></div><div class="biblioentry" id="NE8E"><a name="NE8E"></a><p><span class="abbrev">[Zvon] </span><span class="copyright">Copyright &copy;  http://www.zvon.org/xxl/XPathTutorial/General/examples.html. </span><span class="title"><I>Zvon XPath tutorial</I>. </span></p></div><div class="biblioentry" id="NE96"><a name="NE96"></a><p><span class="abbrev">[RelaxNG] </span><span class="copyright">Copyright &copy;  http://www.oasis-open.org/committees/relax-ng/. </span><span class="title"><I>Developing RELAX NG, the next generation schema language for XML: clean, simple and powerful</I>. </span></p></div><div class="biblioentry" id="NE9E"><a name="NE9E"></a><p><span class="abbrev">[Relax] </span><span class="copyright">Copyright &copy;  http://www.xml.gr.jp/relax/. </span><span class="title"><I>The offical site of Relax</I>. </span></p></div><div class="biblioentry" id="NEA6"><a name="NEA6"></a><p><span class="abbrev">[TREX] </span><span class="copyright">Copyright &copy;  http://www.thaiopensource.com/trex/. </span><span class="title"><I>TREX - Tree Regular Expressions for XML</I>. </span></p></div><div class="biblioentry" id="NEAE"><a name="NEAE"></a><p><span class="abbrev">[DTD] </span><span class="copyright">Copyright &copy;  http://www.w3schools.com/dtd/default.asp. </span><span class="title"><I>Document Type Definitions Tutorial</I>. </span></p></div><div class="biblioentry" id="NEB6"><a name="NEB6"></a><p><span class="abbrev">[XSD] </span><span class="copyright">Copyright &copy;  http://www.w3.org/XML/Schema http://www.w3.org/XML/1998/06/xmlspec-report. </span><span class="title"><I>XML Schema</I>. </span></p></div></div></div></body></html>