/*
 * Copyright (C) 2003 Central Laboratory of the Research Councils
 *
 *  History:
 *     18-NOV-2003 (Peter W. Draper):
 *       Original version.
 */
package uk.ac.starlink.splat.plot;

import java.awt.Rectangle;
import java.awt.Shape;
import java.awt.geom.AffineTransform;
import java.awt.geom.PathIterator;
import java.awt.geom.Point2D;
import java.awt.geom.Rectangle2D;

import uk.ac.starlink.splat.util.Interpolator;

/**
 * A curve generated by an interpolator between a series of vertices.
 *
 * @author Peter W. Draper
 * @version $Id$
 */
public class InterpolatedCurve2D
    implements Shape
{
    /**
     * The interpolation X coordinates.
     */
    double xCoords[] = new double[6];

    /**
     * The interpolated Y coordinates.
     */
    double yCoords[] = new double[6];

    /**
     * The interpolator used to estimate the curve between vertices.
     */
    Interpolator interpolator = null;

    /**
     * Create an empty instance.
     */
    public InterpolatedCurve2D( Interpolator interpolator )
    {
        setInterpolator( interpolator );
    }

    /**
     * Copy constructor.
     */
    public InterpolatedCurve2D( InterpolatedCurve2D in )
    {
        setInterpolator( in.interpolator );
        int count = in.getCoordCount();
        xCoords = new double[count];
        yCoords = new double[count];
        System.arraycopy( in.xCoords, 0, xCoords, 0, count );
        System.arraycopy( in.yCoords, 0, yCoords, 0, count );
    }

    /**
     * Set the interpolator.
     */
    public void setInterpolator( Interpolator interpolator )
    {
        this.interpolator = interpolator;
    }

    /**
     * Get the interpolator.
     */
    public Interpolator getInterpolator()
    {
        return interpolator;
    }


    //  Shape: Not closed so we never contain any points.
    public boolean contains( double x, double y )
    {
        return false;
    }
    public boolean contains( Point2D p )
    {
        return false;
    }
    public boolean contains( Rectangle2D r )
    {
        return false;
    }
    public boolean contains( double x, double y, double w, double h )
    {
        return false;
    }

    //  Shape: Ignore flatness, we do not implement that.
    public PathIterator getPathIterator( AffineTransform at,
                                         double flatness )
    {
        return getPathIterator( at );
    }
    public PathIterator getPathIterator ( AffineTransform at )
    {
        return new InterpolatedCurveIterator( this, at );
    }

    /**
     * Get the number of vertices.
     */
    public int getVertexCount()
    {
        return interpolator.getCount();
    }

    /**
     * Get the number of coordinates.
     */
    public int getCoordCount()
    {
        if ( xCoords != null ) {
            return xCoords.length;
        }
        return 0;
    }

    // Shape: Test if our curve is intersected by the given rectangle.
    public boolean intersects( Rectangle2D r )
    {
        int count = getVertexCount();
        if ( count == 0 ) {
            return false;
        }
        else if ( count == 1 ) {
            return r.contains( getXVertex( 0 ), getYVertex( 0 ) );
        }

        count = getCoordCount();
        double x1;
        double y1;
        double x2 = getXCoord( 0 );
        double y2 = getYCoord( 0 );

        for ( int i = 1; i < count; i++ ) {
            x1 = x2;
            y1 = y2;
            x2 = getXCoord( i );
            y2 = getYCoord( i );
            if ( r.intersectsLine( x1, y1, x2, y2 ) ) {
                return true;
            }
        }
        return false;
    }

    // Shape:
    public boolean intersects( double x, double y, double w, double h )
    {
        return intersects( new Rectangle2D.Double( x, y, w, h ) );
    }

    /**
     * Add a new vertex at the end of the curve. This should also
     * generate the necessary interpolation coordinates.
     */
    public void lineTo( double x, double y )
    {
        interpolator.appendValue( x, y );
        extendXCoords( x );
        yCoords = interpolator.evalYDataArray( xCoords );
    }

    /**
     * Create extra X coordinates for interpolation points. Called
     * after a lineTo adds a new point at the end of the X coordinates.
     */
    protected void extendXCoords( double newx )
    {
        int nextra = interpolator.stepGuess();
        double[] temp = new double[xCoords.length + nextra];
        double step = ( newx - xCoords[xCoords.length-1] ) / (double)nextra;
        System.arraycopy( xCoords, 0, temp, 0, temp.length );
        int offset = temp.length;
        double prev = xCoords[xCoords.length-1];
        for ( int i = 0; i < nextra - 1; i++ ) {
            xCoords[offset+i] = prev + ( i + 1.0 ) * step;
        }
        temp[temp.length-1] = newx;
        xCoords = temp;
    }

    /**
     * Move the start point of the vertex to the given position.
     * Can only be done when curve is first created, or has been reset.
     *
     * @throws UnsupportedOperationException If this isn't the
     *                                       first vertex.
     */
    public void moveTo( double x, double y )
    {
        if ( getVertexCount() > 0 ) {
            throw new UnsupportedOperationException
                ( "InterpolatedCurve2D already has vertices" );
        }
        lineTo( x, y );
    }        

    /**
     * Modify an ordinate.
     */
    public void setX( int index, double newx )
    {
        double[] x = interpolator.getXCoords();
        double[] y = interpolator.getYCoords();
        x[index] = newx;
        interpolator.setCoords( x, y );
        yCoords = interpolator.evalYDataArray( xCoords );
    }

    /**
     * Modify a Y vertex data value.
     */
    public void setY( int index, double newy )
    {
        double[] x = interpolator.getXCoords();
        double[] y = interpolator.getYCoords();
        y[index] = newy;
        interpolator.setCoords( x, y );
        yCoords = interpolator.evalYDataArray( xCoords );
    }

    /**
     * Modify a vertex coordinate.
     */
    public void setY( int index, double newx, double newy )
    {
        double[] x = interpolator.getXCoords();
        double[] y = interpolator.getYCoords();
        x[index] = newx;
        y[index] = newy;
        interpolator.setCoords( x, y );
        yCoords = interpolator.evalYDataArray( xCoords );
    }

    public String toString()
    {
        String string = super.toString();
        StringBuffer buf = new StringBuffer( string );
        for ( int i = 0; i < getVertexCount(); i++ ) {
            buf.append( "(" + getXVertex( i ) + "," + getYVertex( i ) + ")," );
        }
        return buf.toString();
    }

    /**
     * Get the floating-point bounds. As approximate as the
     * drawn interpolated curve.
     */
    public Rectangle2D getBounds2D()
    {
        int count = interpolator.getCount();
        if ( count <= 1 ) {
            return new Rectangle2D.Double();
        }
        double x1 = xCoords[0];
        double y1 = yCoords[1];
        double x2 = x1;
        double y2 = y1;
        for ( int i = 2; i < count; i++ ) {
            if ( xCoords[i] < x1 ) {
                x1 = xCoords[i];
            }
            else if ( xCoords[i] > x2 ) {
                x2 = xCoords[i];
            }
            if ( yCoords[i] < y1 ) {
                y1 = yCoords[i];
            }
            else if ( yCoords[i] > y2 ) {
                y2 = yCoords[i];
            }
        }
        return new Rectangle2D.Double( x1, y1, x2-x1, y2-y1 );
    }
    public Rectangle getBounds ()
    {
        return getBounds2D().getBounds();
    }

    // Check if an index is valid, if not throw an
    // IndexOutOfBoundsException, otherwise do nothing.
    private void checkIndex( int index )
    {
        if ( xCoords == null || index < 0 || index >= xCoords.length ) {
            throw new IndexOutOfBoundsException( "Index: " + index +
                                                 ", Size: " +
                                                 ( xCoords == null ?
                                                   0 : xCoords.length ) );
        }
    }

    /**
     * Get all interpolated X-coordinates.
     */
    public double[] getXCoords()
    {
        return xCoords;
    }

    /**
     * Get all interpolated Y-coordinates.
     */
    public double[] getYCoords()
    {
        return yCoords;
    }

    /**
     * Get an interpolated X-coordinate
     */
    public double getXCoord( int index )
    {
        checkIndex( index );
        return xCoords[index];
    }

    /**
     * Get a interpolated Y-coordinate.
     */
    public double getYCoord( int index )
    {
        checkIndex( index );
        return yCoords[index];
    }

    /**
     * Get the X-coordinate of a vertex.
     */
    public double getXVertex( int index )
    {
        return interpolator.getXCoord( index );
    }

    /**
     * Get the Y-coordinate of a vertex.
     */
    public double getYVertex( int index )
    {
        return interpolator.getYCoord( index );
    }

    /**
     * Set the X-coordinate of a vertex.
     */
    public void setXVertex( int index, double value )
    {
        double[] x = interpolator.getXCoords();
        double[] y = interpolator.getYCoords();
        x[index] = value;
        interpolator.setCoords( x, y );
    }

    /**
     * Set the Y-coordinate of a vertex.
     */
    public void setYVertex( int index, double value )
    {
        double[] x = interpolator.getXCoords();
        double[] y = interpolator.getYCoords();
        y[index] = value;
        interpolator.setCoords( x, y );
    }

    /**
     * Set the coordinates of a vertex.
     */
    public void setVertex( int index, double xValue, double yValue )
    {
        double[] x = interpolator.getXCoords();
        double[] y = interpolator.getYCoords();
        x[index] = xValue;
        y[index] = yValue;
        interpolator.setCoords( x, y );
    }

    /**
     * Transform the vertex positions.
     */
    public void transform( AffineTransform at )
    {
        double[] x = interpolator.getXCoords();
        double[] y = interpolator.getYCoords();
        double[] xy = new double[x.length*2];
        int j = 0;
        for ( int i = 0; i < x.length; i++ ) {
            xy[j++] = x[i];
            xy[j++] = y[i]; 
        }
        at.transform( xy, 0, xy, 0, x.length );
        j = 0;
        for ( int i = 0; i < x.length; i++ ) {
            x[i] = xy[j++];
            y[i] = xy[j++];
        }
        interpolator.setCoords( x, y );
    }
    
    /**
     * Translate the vertex positions.
     */
    public void translate( double dx, double dy )
    {
        double[] x = interpolator.getXCoords();
        double[] y = interpolator.getYCoords();

        for ( int i = 0; i < x.length; i++ ) {
            x[i] += dx;
            y[i] += dy; 
        }
        interpolator.setCoords( x, y );
    }
}
