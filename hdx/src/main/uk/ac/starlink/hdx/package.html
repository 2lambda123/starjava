<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<html>
<head>
<!--

  $Id$

-->
</head>
<body>
Provides the structuring for the HDX system.

<p>This is the package which defines the structure of the HDX system,
registers new types, and is responsible for managing the 
implementations of the various factories required.</p>

<p>HDX is defined as a DOM: an HDX is a DOM
{@link org.w3c.dom.Document} node,
which has a document element of type <code>&lt;hdx&gt;</code>, which
in turn contains other elements of <a href="#hdxtypes" >registered
types</a>.  HDX does not define or constrain these other types
(instead providing facilities for <a href="#newtypes" >defining
them</a>), other than to require that they be defined in DOM terms.
The structure and semantics of these other types are defined using DOM
terminology, and they are always representable as a DOM, and are
navigable, manipulable, and in some cases modifiable, using that
DOM.</p>

<p>The types are not generally processable using the DOM, however, and 
so they must be turned into a Java object before work can be done on
them.  This transformation may involve significant work, if the object 
has to be constructed from information in the DOM, or it may 
be trivial, if the DOM in fact mirrors some underlying object.  During 
processing, the object will generally be manipulated using some
interface defined as part of that object's specification.</p>

<h2 name="hdxtypes">HDX types</h2>

<p>All important elements in the HDX DOM correspond to types
registered with the HDX system.  Only those elements which correspond
to registered types can be constructed.  However, not all elements
must be registered -- elements which are embedded within important
types, and which do not have to be children of the
<code>&lt;hdx&gt;</code> element, do not have to be registered or have 
handlers.</p>

<p>Types are registered by creating an instance of class
{@link uk.ac.starlink.hdx.HdxResourceType}, using the static method
{@link uk.ac.starlink.hdx.HdxResourceType#newHdxResourceType newHdxResourceType}.
See <a href="#newtypes" >below</a> for an example.</p>

<h2>Important classes and interfaces</h2>

<p>The two core classes in the Hdx package are 
{@link uk.ac.starlink.hdx.HdxResourceType}, instances of which define
the types known to Hdx, and
{@link uk.ac.starlink.hdx.HdxFactory}, which marshalls the various
factories responsible for creating objects and the DOM representations 
of them.</p>

<p>The most important interfaces are
{@link uk.ac.starlink.hdx.HdxContainer},
{@link uk.ac.starlink.hdx.HdxDocumentFactory}, and
{@link uk.ac.starlink.hdx.HdxResourceFactory}.
<code>HdxContainer</code> is the type which represents an Hdx object
as a whole, and implementations of <code>HdxDocumentFactory</code>
are what constructs such objects from URLs.  A class which is able to
construct a DOM from a particular class of URL -- such as a URL
pointing to a FITS file, for example -- registers a
<code>HdxDocumentFactory</code> instance with
<code>HdxFactory</code>'s
{@link uk.ac.starlink.hdx.HdxFactory#registerHdxResourceFactory registerHdxResourceFactory}:
when <code>HdxFactory</code> is asked to construct a DOM by a call
to its
{@link uk.ac.starlink.hdx.HdxFactory#newHdxContainer newHdxContainer}
method, it works through the list of registered factories until one of 
them successfully constructs the DOM.</p>

<p>Implementations of the
<code>HdxResourceFactory</code> type are responsible for turning a DOM 
element into a Java object.</p>

<h2 a name="namespaces">Namespaces</h2>

<p>Hdx objects may be synthesized from binary data files such as HDS
or FITS files, or else they may be extracted from the DOMs constructed from
XML files.  If the element passed to method 
{@link uk.ac.starlink.hdx.HdxFactory#newHdxContainer(org.w3c.dom.Element) newHdxContainer(Element)}
corresponds to a registered Hdx type and it is in no namespace, then
the input DOM is processed as you might expect.</p>

<p>The factory can also process elements in a more sophisticated way.
If the element passed to <code>newHdxContainer</code> does not
correspond to a registered type, or it is in the Hdx namespace, then
the method will examine <em>only</em> those elements and attributes in
the Hdx namespace
(see W3C <a href="http://www.w3.org/TR/REC-xml-names/" >namespaces
spec</a>).  This means that the Hdx information is able to be carried
inside another unrelated XML file, invisible to a namespace-aware
processor examinging only the `background' XML.</p>

<p>The Hdx namespace is defined to be
<code>http://www.starlink.ac.uk/HDX</code>, which string is accessible 
as
{@link uk.ac.starlink.hdx.HdxResourceType#HDX_NAMESPACE}.  The Hdx DOM
which is constructed from such an input element contains only the
Hdx-registered elements, in no namespace, so that users of the DOM do
not have to worry about the occasionally subtle details of namespace
processing.  Thus the XML file</p>

<pre>
    &lt;rubbish xmlns:x="http://www.starlink.ac.uk/HDX">
      &lt;x:hdx>
        &lt;x:ndx>
          &lt;x:data uri="file:/tmp/mydata.sdf"/>
        &lt;/x:ndx>
      &lt;/x:hdx>
    &lt;/rubbish>
</pre>

<p>is transformed into the simpler DOM</p>

<pre>
    &lt;hdx>
      &lt;ndx>
        &lt;data uri="file:/tmp/mydata.sdf"/>
      &lt;/ndx>
    &lt;/hdx>
</pre>

<p>Changes made to the attributes in this transformed DOM are
reflected in the original DOM.</p>

<p>Further transformations happen when a DOM is imported into
Hdx.  Firstly, the attribute `<code>name</code>' in the Hdx namespace 
is transformed into an element with that name.  Secondly, if an
Hdx type has a `hoist' attribute defined (see
{@link uk.ac.starlink.hdx.HdxResourceType#setHoistAttribute setHoistAttribute}),
then any text content of the element will be hoisted up to form the
content of that hoist attribute.  Finally, if the Hdx DOM which
results from this does not have <code>&lt;hdx&gt;</code> as its top
element, but instead an element which is a valid child of
<code>&lt;hdx&gt;</code>, then it is inserted into a
<code>&lt;hdx&gt;</code> element.  Thus</p>

<pre>
    &lt;mystructure>
      &lt;mypointer x:name="ndx" xmlns:x="http://www.starlink.ac.uk/HDX">
        mydata.sdf
      &lt;/mypointer>
    &lt;/mystructure>
</pre>

<p>is transformed into</p>

<pre>
    &lt;hdx>
      &lt;ndx uri="mydata.sdf"/>
    &lt;/hdx>
</pre>

<p>and processed accordingly.</p>

<p>If you are particularly familiar with the W3C Namespaces spec, then 
you will have objected that the `<code>uri</code>' attribute in the
first example was formally in <em>no</em> namespace, and should not
therefore have been processed.  This is true, but it is so unhelpfully 
counter-intuitive that as a special case, the normalisation process
described here processes such no-namespace attributes in the Hdx
namespace <em>if</em> the element is itself in the Hdx namespace, as
is the case in the example above.</p>

<h2>Usage: reading XML and other files</h2>

<p>Use
<code>{@link uk.ac.starlink.hdx.HdxFactory}.{@link uk.ac.starlink.hdx.HdxFactory#getInstance getInstance()}.{@link uk.ac.starlink.hdx.HdxFactory#newHdxContainer(java.net.URI)
newHdxContainer(URI)}</code> to extract HDX objects from URIs, and
method
{@link uk.ac.starlink.hdx.HdxFactory#newHdxContainer(org.w3c.dom.Element) newHdxContainer(Element)}
to extract Hdx objects from DOMs, using the namespace mechanism
described <a href="#namespaces">above</a>.</p>

<h2 name="newtypes">Usage: defining new types</h2>

<p>To define a new type, you must create a new
{@link uk.ac.starlink.hdx.HdxResourceType}, using method
{@link uk.ac.starlink.hdx.HdxResourceType#newHdxResourceType newHdxResourceType}, and then act
on the resulting object to register validators and constructors.  For
example, the (very simple) definition of the
{@link uk.ac.starlink.hdx.HdxResourceType#TITLE} object consists of:</p>

<pre>
     TITLE = newHdxResourceType("title");
     TITLE.setHoistAttribute("value");
     TITLE.setElementValidator(new ElementValidator() {
         public boolean validateElement(Element el) {
             // A TITLE element is valid if it has an attribute "value"
             return HdxResourceType.match(el) == TITLE
                 && el.hasAttribute(TITLE.getHoistAttribute());
         }
     });
</pre>

<p>The {@link uk.ac.starlink.hdx.HdxResourceType#HDX} type has a somewhat more
complicated validator, plus the assertion</p>

<pre>
     HDX.setConstructedClass("uk.ac.starlink.hdx.HdxContainer");
</pre>

<p>that constructed (Java) objects must be instances of the
{@link uk.ac.starlink.hdx.HdxContainer} interface.</p>

<h2>Usage: adding new file formats</h2>

<p>To add a new format which can be given a DOM interface, you must
create a class which implements
{@link uk.ac.starlink.hdx.HdxDocumentFactory},
which turns a URL into a DOM Document.</p>

<p><strong>XXX</strong> Details about registering the class.  To appear.</p>

<p>These factories can be arbitrarily clever.  They can either create
a simple DOM and wait for the work of reading the file to be done by
the constructors registered with the type using
{@link uk.ac.starlink.hdx.HdxFactory#registerHdxResourceFactory}, or else the factory can construct the
object, using a class which implements the {@link uk.ac.starlink.hdx.DOMFacade}
interface, and then create an Element which uses that facade using
{@link uk.ac.starlink.hdx.HdxDocument#createElement(HdxResourceType,DOMFacade)}.</p>

<p>That covers construction of a complete Hdx DOM from a URI.
However, you should also handle, if appropriate, a reference to your
new file format from within a DOM.  In the case of the Ndx type, that
can be done with a construction such as</p>

<pre>
     ndxType.registerHdxResourceFactory(new HdxResourceFactory() {
         public Object getObject(Element el)
                 throws HdxException {
             return new BridgeNdx(new DomNdxImpl(el));
         }
     });
</pre>

<p>where <code>ndxType</code> is the <code>HdxResourceType</code>
object which this initialiser has obtained either from
<code>HdxResourceType.match("ndx")</code> or, preferably, from its
initialisation of the Ndx type using <code>newHdxResourceType</code>.
The class <code>DomNdxImpl</code> is a class which is private to the
Ndx package.</p>

<h2>Related Documentation</h2>

<p>See the 
<a href="http://www.starlink.ac.uk" >Starlink web pages</a>.

<!-- Put @see and @since tags down here. -->

</body>
</html>
